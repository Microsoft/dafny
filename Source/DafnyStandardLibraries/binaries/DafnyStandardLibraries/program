// dafny 4.3.0.0
// 
// the_program


module DafnyStdLibs.Arithmetic.DivInternalsNonlinear {
  lemma LemmaDivOf0(d: int)
    requires d != 0
    ensures 0 / d == 0
  {
  }

  lemma LemmaDivBySelf(d: int)
    requires d != 0
    ensures d / d == 1
  {
  }

  lemma LemmaSmallDiv()
    ensures forall x, d {:trigger x / d} :: 0 <= x < d && d > 0 ==> x / d == 0
  {
  }

  lemma LemmaRealDivGt(x: real, y: real)
    requires x > y
    requires y > 0.0
    ensures x / y > 1 as real
  {
  }
}

module DafnyStdLibs.Arithmetic.ModInternalsNonlinear {
  lemma LemmaModOfZeroIsZero(m: int)
    requires 0 < m
    ensures 0 % m == 0
  {
  }

  lemma LemmaFundamentalDivMod(x: int, d: int)
    requires d != 0
    ensures x == d * (x / d) + x % d
  {
  }

  lemma Lemma0ModAnything()
    ensures forall m: int {:trigger 0 % m} :: m > 0 ==> 0 % m == 0
  {
  }

  lemma LemmaSmallMod(x: nat, m: nat)
    requires x < m
    requires 0 < m
    ensures x % m == x
  {
  }

  lemma LemmaModRange(x: int, m: int)
    requires m > 0
    ensures 0 <= x % m < m
  {
  }
}

module DafnyStdLibs.Arithmetic.MulInternalsNonlinear {
  lemma LemmaMulStrictlyPositive(x: int, y: int)
    ensures 0 < x && 0 < y ==> 0 < x * y
  {
  }

  lemma LemmaMulNonzero(x: int, y: int)
    ensures x * y != 0 <==> x != 0 && y != 0
  {
  }

  lemma LemmaMulIsAssociative(x: int, y: int, z: int)
    ensures x * (y * z) == x * y * z
  {
  }

  lemma LemmaMulIsDistributiveAdd(x: int, y: int, z: int)
    ensures x * (y + z) == x * y + x * z
  {
  }

  lemma LemmaMulOrdering(x: int, y: int)
    requires x != 0
    requires y != 0
    requires 0 <= x * y
    ensures x * y >= x && x * y >= y
  {
  }

  lemma LemmaMulStrictInequality(x: int, y: int, z: int)
    requires x < y
    requires z > 0
    ensures x * z < y * z
  {
  }
}

module DafnyStdLibs.Base64 {
  opaque predicate IsBase64Char(c: char)
  {
    c == '+' || c == '/' || '0' <= c <= '9' || 'A' <= c <= 'Z' || 'a' <= c <= 'z'
  }

  lemma Base64CharIs7Bit(c: char)
    requires IsBase64Char(c)
    ensures c < 128 as char
  {
    reveal IsBase64Char();
  }

  opaque predicate IsUnpaddedBase64String(s: string)
  {
    |s| % 4 == 0 &&
    forall k :: 
      k in s ==>
        IsBase64Char(k)
  }

  opaque function IndexToChar(i: index): (c: char)
    ensures IsBase64Char(c)
  {
    reveal IsBase64Char();
    if i == 63 then
      '/'
    else if i == 62 then
      '+'
    else if 52 <= i <= 61 then
      (i - 4) as char
    else if 26 <= i <= 51 then
      i as char + 71 as char
    else
      i as char + 65 as char
  }

  lemma IndexToCharIsBase64(i: index)
    ensures IsBase64Char(IndexToChar(i))
  {
    reveal IndexToChar();
    reveal IsBase64Char();
  }

  opaque function CharToIndex(c: char): (i: index)
    requires IsBase64Char(c)
  {
    reveal IsBase64Char();
    reveal IndexToChar();
    if c == '/' then
      63
    else if c == '+' then
      62
    else if '0' <= c <= '9' then
      (c + 4 as char) as index
    else if 'a' <= c <= 'z' then
      (c - 71 as char) as index
    else
      (c - 65 as char) as index
  }

  lemma {:rlimit 2000} {:vcs_split_on_every_assert} CharToIndexToChar(c: char)
    requires IsBase64Char(c)
    ensures IndexToChar(CharToIndex(c)) == c
  {
    Base64CharIs7Bit(c);
    reveal IsBase64Char();
    reveal IndexToChar();
    reveal CharToIndex();
    if c == '/' {
      assert IndexToChar(CharToIndex(c)) == c;
    } else if c == '+' {
      assert IndexToChar(CharToIndex(c)) == c;
    } else if '0' <= c <= '9' {
      assert IndexToChar(CharToIndex(c)) == c;
    } else if 'a' <= c < 'm' {
      assert IndexToChar(CharToIndex(c)) == c;
    } else if 'm' <= c <= 'z' {
      assert IndexToChar(CharToIndex(c)) == c;
    } else {
      assert IndexToChar(CharToIndex(c)) == c;
    }
  }

  lemma {:vcs_split_on_every_assert} IndexToCharToIndex(i: index)
    ensures (IndexToCharIsBase64(i); CharToIndex(IndexToChar(i)) == i)
  {
    reveal IsBase64Char();
    reveal IndexToChar();
    reveal CharToIndex();
    IndexToCharIsBase64(i);
    if i == 63 {
      assert CharToIndex(IndexToChar(i)) == i;
    } else if i == 62 {
      assert CharToIndex(IndexToChar(i)) == i;
    } else if 52 <= i <= 61 {
      assert CharToIndex(IndexToChar(i)) == i;
    } else if 26 <= i <= 51 {
      assert CharToIndex(IndexToChar(i)) == i;
    } else {
      assert CharToIndex(IndexToChar(i)) == i;
    }
  }

  lemma IndexToCharToIndexAuto()
    ensures forall x :: (IndexToCharIsBase64(x); CharToIndex(IndexToChar(x)) == x)
  {
    forall x: index | true
      ensures (IndexToCharIsBase64(x); CharToIndex(IndexToChar(x)) == x)
    {
      IndexToCharToIndex(x);
    }
  }

  lemma CharToIndexToCharAuto()
    ensures forall c | IsBase64Char(c) :: IndexToChar(CharToIndex(c)) == c
  {
    forall c: char | IsBase64Char(c)
      ensures IndexToChar(CharToIndex(c)) == c
    {
      CharToIndexToChar(c);
    }
  }

  opaque function BV24ToSeq(x: bv24): (ret: seq<bv8>)
    ensures |ret| == 3
  {
    var b0 := ((x >> 16) & 255) as bv8;
    var b1 := ((x >> 8) & 255) as bv8;
    var b2 := (x & 255) as bv8;
    [b0, b1, b2]
  }

  opaque function SeqToBV24(x: seq<bv8>): (ret: bv24)
    requires |x| == 3
  {
    (x[0] as bv24 << 16) | (x[1] as bv24 << 8) | x[2] as bv24
  }

  lemma BV24ToSeqToBV24(x: bv24)
    ensures SeqToBV24(BV24ToSeq(x)) == x
  {
    reveal BV24ToSeq();
    reveal SeqToBV24();
  }

  lemma SeqToBV24ToSeq(s: seq<bv8>)
    requires |s| == 3
    ensures BV24ToSeq(SeqToBV24(s)) == s
  {
    reveal SeqToBV24();
    reveal BV24ToSeq();
  }

  opaque function BV24ToIndexSeq(x: bv24): (ret: seq<index>)
    ensures |ret| == 4
  {
    var b0 := ((x >> 18) & 63) as index;
    var b1 := ((x >> 12) & 63) as index;
    var b2 := ((x >> 6) & 63) as index;
    var b3 := (x & 63) as index;
    [b0, b1, b2, b3]
  }

  opaque function IndexSeqToBV24(x: seq<index>): (ret: bv24)
    requires |x| == 4
  {
    (x[0] as bv24 << 18) | (x[1] as bv24 << 12) | (x[2] as bv24 << 6) | x[3] as bv24
  }

  lemma BV24ToIndexSeqToBV24(x: bv24)
    ensures IndexSeqToBV24(BV24ToIndexSeq(x)) == x
  {
    reveal IndexSeqToBV24();
    reveal BV24ToIndexSeq();
  }

  lemma IndexSeqToBV24ToIndexSeq(s: seq<index>)
    requires |s| == 4
    ensures BV24ToIndexSeq(IndexSeqToBV24(s)) == s
  {
    reveal IndexSeqToBV24();
    reveal BV24ToIndexSeq();
  }

  opaque function DecodeBlock(s: seq<index>): (ret: seq<bv8>)
    requires |s| == 4
    ensures |ret| == 3
  {
    BV24ToSeq(IndexSeqToBV24(s))
  }

  opaque function EncodeBlock(s: seq<bv8>): (ret: seq<index>)
    requires |s| == 3
    ensures |ret| == 4
  {
    BV24ToIndexSeq(SeqToBV24(s))
  }

  lemma EncodeDecodeBlock(s: seq<bv8>)
    requires |s| == 3
    ensures DecodeBlock(EncodeBlock(s)) == s
  {
    reveal EncodeBlock();
    reveal DecodeBlock();
    var b := SeqToBV24(s);
    BV24ToIndexSeqToBV24(b);
    SeqToBV24ToSeq(s);
  }

  lemma DecodeEncodeBlock(s: seq<index>)
    requires |s| == 4
    ensures EncodeBlock(DecodeBlock(s)) == s
  {
    reveal EncodeBlock();
    reveal DecodeBlock();
    var b := IndexSeqToBV24(s);
    BV24ToSeqToBV24(b);
    IndexSeqToBV24ToIndexSeq(s);
  }

  opaque function {:vcs_split_on_every_assert} DecodeRecursively(s: seq<index>): (b: seq<bv8>)
    requires |s| % 4 == 0
    decreases |s|
  {
    if |s| == 0 then
      []
    else
      DecodeBlock(s[..4]) + DecodeRecursively(s[4..])
  } by method {
    var resultLength := |s| / 4 * 3;
    var result := new bv8[resultLength] (i => 0);
    var i := |s|;
    var j := resultLength;
    reveal DecodeRecursively();
    while i > 0
      invariant i % 4 == 0
      invariant 0 <= i <= |s|
      invariant i * 3 == j * 4
      invariant 0 <= j <= resultLength
      invariant result[j..] == DecodeRecursively(s[i..])
    {
      i := i - 4;
      j := j - 3;
      var block := DecodeBlock(s[i .. i + 4]);
      result[j] := block[0];
      result[j + 1] := block[1];
      result[j + 2] := block[2];
      assert s[i..][..4] == s[i .. i + 4];
      assert s[i..][4..] == s[i + 4..];
      assert result[j .. j + 3] == block;
      calc {
        DecodeBlock(s[i .. i + 4]) + DecodeRecursively(s[i + 4..]);
        DecodeBlock(s[i..][..4]) + DecodeRecursively(s[i..][4..]);
        DecodeRecursively(s[i..]);
      }
    }
    b := result[..];
  }

  lemma DecodeRecursivelyBounds(s: seq<index>)
    requires |s| % 4 == 0
    ensures |DecodeRecursively(s)| == |s| / 4 * 3
    ensures |DecodeRecursively(s)| % 3 == 0
    ensures |DecodeRecursively(s)| == 0 ==> |s| == 0
  {
    reveal DecodeRecursively();
  }

  lemma DecodeRecursivelyBlock(s: seq<index>)
    requires |s| % 4 == 0
    ensures (DecodeRecursivelyBounds(s); var b := DecodeRecursively(s); |b| != 0 ==> EncodeBlock(b[..3]) == s[..4])
  {
    DecodeRecursivelyBounds(s);
    if |s| == 0 {
    } else {
      DecodeEncodeBlock(s[..4]);
      reveal DecodeRecursively();
    }
  }

  opaque function {:vcs_split_on_every_assert} EncodeRecursively(b: seq<bv8>): (s: seq<index>)
    requires |b| % 3 == 0
  {
    if |b| == 0 then
      []
    else
      EncodeBlock(b[..3]) + EncodeRecursively(b[3..])
  } by method {
    var resultLength := |b| / 3 * 4;
    var result := new index[resultLength] (i => 0);
    var i := |b|;
    var j := resultLength;
    reveal EncodeRecursively();
    while i > 0
      invariant i % 3 == 0
      invariant 0 <= i <= |b|
      invariant i * 4 == j * 3
      invariant 0 <= j <= resultLength
      invariant result[j..] == EncodeRecursively(b[i..])
    {
      i := i - 3;
      j := j - 4;
      var block := EncodeBlock(b[i .. i + 3]);
      result[j] := block[0];
      result[j + 1] := block[1];
      result[j + 2] := block[2];
      result[j + 3] := block[3];
      assert b[i..][..3] == b[i .. i + 3];
      assert b[i..][3..] == b[i + 3..];
      assert result[j .. j + 4] == block;
      calc {
        EncodeBlock(b[i .. i + 3]) + EncodeRecursively(b[i + 3..]);
        EncodeBlock(b[i..][..3]) + EncodeRecursively(b[i..][3..]);
        EncodeRecursively(b[i..]);
      }
    }
    s := result[..];
  }

  lemma EncodeRecursivelyBounds(b: seq<bv8>)
    requires |b| % 3 == 0
    ensures |EncodeRecursively(b)| == |b| / 3 * 4
    ensures |EncodeRecursively(b)| % 4 == 0
    ensures |EncodeRecursively(b)| == 0 ==> |b| == 0
  {
    reveal EncodeRecursively();
  }

  lemma EncodeRecursivelyBlock(b: seq<bv8>)
    requires |b| % 3 == 0
    ensures (EncodeRecursivelyBounds(b); var s := EncodeRecursively(b); |s| != 0 ==> DecodeBlock(s[..4]) == b[..3])
  {
    EncodeRecursivelyBounds(b);
    if |b| == 0 {
    } else {
      EncodeDecodeBlock(b[..3]);
      reveal EncodeRecursively();
    }
  }

  lemma EncodeDecodeRecursively(b: seq<bv8>)
    requires |b| % 3 == 0
    ensures (EncodeRecursivelyBounds(b); DecodeRecursively(EncodeRecursively(b)) == b)
  {
    var s := EncodeRecursively(b);
    EncodeRecursivelyBounds(b);
    DecodeRecursivelyBounds(s);
    if |b| == 0 {
    } else {
      calc {
        DecodeRecursively(EncodeRecursively(b));
      ==
        DecodeRecursively(s);
      ==
        {
          reveal DecodeRecursively();
        }
        DecodeBlock(s[..4]) + DecodeRecursively(s[4..]);
      ==
        {
          EncodeRecursivelyBlock(b);
        }
        b[..3] + DecodeRecursively(s[4..]);
      ==
        {
          reveal EncodeRecursively();
        }
        b[..3] + DecodeRecursively(EncodeRecursively(b[3..]));
      ==
        {
          EncodeDecodeRecursively(b[3..]);
        }
        b[..3] + b[3..];
      ==
        b;
      }
    }
  }

  lemma DecodeEncodeRecursively(s: seq<index>)
    requires |s| % 4 == 0
    ensures (DecodeRecursivelyBounds(s); EncodeRecursively(DecodeRecursively(s)) == s)
  {
    var b := DecodeRecursively(s);
    DecodeRecursivelyBounds(s);
    EncodeRecursivelyBounds(b);
    if |s| == 0 {
    } else {
      calc {
        EncodeRecursively(DecodeRecursively(s));
      ==
        EncodeRecursively(b);
      ==
        {
          reveal EncodeRecursively();
        }
        EncodeBlock(b[..3]) + EncodeRecursively(b[3..]);
      ==
        {
          DecodeRecursivelyBlock(s);
        }
        s[..4] + EncodeRecursively(b[3..]);
      ==
        {
          reveal DecodeRecursively();
        }
        s[..4] + EncodeRecursively(DecodeRecursively(s[4..]));
      ==
        {
          DecodeEncodeRecursively(s[4..]);
        }
        s[..4] + s[4..];
      ==
        s;
      }
    }
  }

  opaque function FromCharsToIndices(s: seq<char>): (b: seq<index>)
    requires forall k :: k in s ==> IsBase64Char(k)
    ensures |b| == |s|
  {
    seq(|s|, i requires 0 <= i < |s| => CharToIndex(s[i]))
  }

  opaque function FromIndicesToChars(b: seq<index>): (s: seq<char>)
    ensures forall k :: k in s ==> IsBase64Char(k)
    ensures |s| == |b|
  {
    seq(|b|, i requires 0 <= i < |b| => IndexToChar(b[i]))
  }

  lemma FromCharsToIndicesToChars(s: seq<char>)
    requires forall k :: k in s ==> IsBase64Char(k)
    ensures FromIndicesToChars(FromCharsToIndices(s)) == s
  {
    reveal FromIndicesToChars();
    reveal FromCharsToIndices();
    CharToIndexToCharAuto();
  }

  lemma FromIndicesToCharsToIndices(b: seq<index>)
    ensures FromCharsToIndices(FromIndicesToChars(b)) == b
  {
    reveal FromIndicesToChars();
    reveal FromCharsToIndices();
    IndexToCharToIndexAuto();
  }

  opaque function DecodeUnpadded(s: seq<char>): (b: seq<bv8>)
    requires IsUnpaddedBase64String(s)
  {
    reveal IsUnpaddedBase64String();
    DecodeRecursively(FromCharsToIndices(s))
  }

  lemma DecodeUnpaddedBounds(s: seq<char>)
    requires IsUnpaddedBase64String(s)
    ensures |DecodeUnpadded(s)| == |s| / 4 * 3
    ensures |DecodeUnpadded(s)| % 3 == 0
  {
    reveal DecodeUnpadded();
    reveal IsUnpaddedBase64String();
    reveal IsBase64String();
    var indices := FromCharsToIndices(s);
    assert |indices| == |s|;
    DecodeRecursivelyBounds(indices);
  }

  opaque function EncodeUnpadded(b: seq<bv8>): (s: seq<char>)
    requires |b| % 3 == 0
  {
    EncodeDecodeRecursively(b);
    FromIndicesToChars(EncodeRecursively(b))
  }

  lemma EncodeUnpaddedNotPadded(b: seq<bv8>)
    requires |b| % 3 == 0
    requires b != []
    ensures (EncodeUnpaddedBounds(b); var s := EncodeUnpadded(b); !Is1Padding(s[|s| - 4..]) && !Is2Padding(s[|s| - 4..]))
  {
    var s := EncodeUnpadded(b);
    EncodeUnpaddedBounds(b);
    var suffix := s[|s| - 4..];
    reveal EncodeUnpadded();
    assert forall c :: c in s ==> IsBase64Char(c);
    assert IsBase64Char(s[|s| - 1]);
    assert s[|s| - 1] != '=' by {
      reveal IsBase64Char();
    }
    reveal Is1Padding();
    reveal Is2Padding();
  }

  lemma EncodeUnpaddedBounds(b: seq<bv8>)
    requires |b| % 3 == 0
    ensures |EncodeUnpadded(b)| == |b| / 3 * 4
    ensures |EncodeUnpadded(b)| % 4 == 0
  {
    reveal EncodeUnpadded();
    EncodeRecursivelyBounds(b);
  }

  lemma EncodeUnpaddedBase64(b: seq<bv8>)
    requires |b| % 3 == 0
    ensures IsUnpaddedBase64String(EncodeUnpadded(b))
  {
    reveal EncodeUnpadded();
    EncodeRecursivelyBounds(b);
    reveal IsUnpaddedBase64String();
  }

  lemma EncodeDecodeUnpadded(b: seq<bv8>)
    requires |b| % 3 == 0
    ensures (EncodeUnpaddedBounds(b); EncodeUnpaddedBase64(b); DecodeUnpadded(EncodeUnpadded(b)) == b)
  {
    EncodeUnpaddedBase64(b);
    calc {
      DecodeUnpadded(EncodeUnpadded(b));
    ==
      {
        reveal EncodeUnpadded();
      }
      DecodeUnpadded(FromIndicesToChars(EncodeRecursively(b)));
    ==
      {
        reveal DecodeUnpadded();
        EncodeRecursivelyBounds(b);
      }
      DecodeRecursively(FromCharsToIndices(FromIndicesToChars(EncodeRecursively(b))));
    ==
      {
        FromIndicesToCharsToIndices(EncodeRecursively(b));
      }
      DecodeRecursively(EncodeRecursively(b));
    ==
      {
        EncodeDecodeRecursively(b);
      }
      b;
    }
  }

  lemma DecodeEncodeUnpadded(s: seq<char>)
    requires |s| % 4 == 0
    requires IsUnpaddedBase64String(s)
    ensures (DecodeUnpaddedBounds(s); EncodeUnpadded(DecodeUnpadded(s)) == s)
  {
    DecodeUnpaddedBounds(s);
    reveal IsUnpaddedBase64String();
    var fromCharsToIndicesS := FromCharsToIndices(s);
    calc {
      EncodeUnpadded(DecodeUnpadded(s));
    ==
      {
        reveal DecodeUnpadded();
      }
      EncodeUnpadded(DecodeRecursively(FromCharsToIndices(s)));
    ==
      EncodeUnpadded(DecodeRecursively(fromCharsToIndicesS));
    ==
      {
        reveal EncodeUnpadded();
      }
      assert |fromCharsToIndicesS| % 4 == 0; FromIndicesToChars(EncodeRecursively(DecodeRecursively(fromCharsToIndicesS)));
    ==
      {
        DecodeEncodeRecursively(fromCharsToIndicesS);
      }
      FromIndicesToChars(fromCharsToIndicesS);
    ==
      FromIndicesToChars(FromCharsToIndices(s));
    ==
      {
        FromCharsToIndicesToChars(s);
      }
      s;
    }
  }

  opaque predicate Is1Padding(s: seq<char>)
  {
    |s| == 4 &&
    IsBase64Char(s[0]) &&
    IsBase64Char(s[1]) &&
    IsBase64Char(s[2]) &&
    CharToIndex(s[2]) & 3 == 0 &&
    s[3] == '='
  }

  opaque function Decode1Padding(s: seq<char>): (b: seq<bv8>)
    requires Is1Padding(s)
    ensures |b| == 2
  {
    reveal Is1Padding();
    var d := DecodeBlock([CharToIndex(s[0]), CharToIndex(s[1]), CharToIndex(s[2]), 0]);
    [d[0], d[1]]
  }

  opaque function Encode1Padding(b: seq<bv8>): (s: seq<char>)
    requires |b| == 2
    ensures |s| % 4 == 0
    ensures |s| == 4
  {
    var e := EncodeBlock([b[0], b[1], 0]);
    IndexToCharIsBase64(e[0]);
    IndexToCharIsBase64(e[1]);
    IndexToCharIsBase64(e[2]);
    [IndexToChar(e[0]), IndexToChar(e[1]), IndexToChar(e[2]), '=']
  }

  lemma EncodeDecodeBlock1Padding(b: seq<bv8>)
    requires |b| == 2
    ensures var e := EncodeBlock([b[0], b[1], 0]); var d := DecodeBlock([e[0], e[1], e[2], 0]); [d[0], d[1]] == b
  {
    reveal EncodeBlock();
    reveal DecodeBlock();
    reveal BV24ToSeq();
    reveal SeqToBV24();
    reveal IndexSeqToBV24();
    reveal BV24ToIndexSeq();
  }

  lemma Encode1PaddingIs1Padding(b: seq<bv8>)
    requires |b| == 2
    ensures Is1Padding(Encode1Padding(b))
  {
    var s := Encode1Padding(b);
    var e := EncodeBlock([b[0], b[1], 0]);
    assert s == [IndexToChar(e[0]), IndexToChar(e[1]), IndexToChar(e[2]), '='] by {
      reveal Encode1Padding();
    }
    IndexToCharIsBase64(e[0]);
    IndexToCharIsBase64(e[1]);
    IndexToCharIsBase64(e[2]);
    assert CharToIndex(s[2]) & 3 == 0 by {
      reveal Encode1Padding();
      reveal EncodeBlock();
      reveal IndexToChar();
      reveal CharToIndex();
      reveal BV24ToIndexSeq();
      reveal SeqToBV24();
    }
    assert Is1Padding(s) by {
      reveal Is1Padding();
    }
  }

  lemma EncodeDecode1Padding(b: seq<bv8>)
    requires |b| == 2
    ensures (Encode1PaddingIs1Padding(b); Decode1Padding(Encode1Padding(b)) == b)
  {
    Encode1PaddingIs1Padding(b);
    var e := EncodeBlock([b[0], b[1], 0]);
    var s := [CharToIndex(IndexToChar(e[0])), CharToIndex(IndexToChar(e[1])), CharToIndex(IndexToChar(e[2])), 0];
    var s' := [e[0], e[1], e[2], 0];
    var d := DecodeBlock(s);
    var d' := DecodeBlock(s');
    calc {
      Decode1Padding(Encode1Padding(b));
    ==
      {
        reveal Encode1Padding();
      }
      Decode1Padding([IndexToChar(e[0]), IndexToChar(e[1]), IndexToChar(e[2]), '=']);
    ==
      {
        reveal Decode1Padding();
      }
      [d[0], d[1]];
    ==
      {
        IndexToCharToIndex(e[0]);
        IndexToCharToIndex(e[1]);
        IndexToCharToIndex(e[2]);
      }
      [d'[0], d'[1]];
    ==
      {
        EncodeDecodeBlock1Padding(b);
      }
      b;
    }
  }

  lemma {:vcs_split_on_every_assert} DecodeEncode1Padding(s: seq<char>)
    requires Is1Padding(s)
    ensures Encode1Padding(Decode1Padding(s)) == s
  {
    reveal Is1Padding();
    var i := [CharToIndex(s[0]), CharToIndex(s[1]), CharToIndex(s[2]), 0];
    var d := DecodeBlock(i);
    var e := EncodeBlock([d[0], d[1], 0]);
    var d' := [IndexToChar(e[0]), IndexToChar(e[1]), IndexToChar(e[2]), '='];
    calc {
      Encode1Padding(Decode1Padding(s));
    ==
      {
        reveal Decode1Padding();
      }
      Encode1Padding([d[0], d[1]]);
    ==
      {
        reveal Encode1Padding();
      }
      d';
    ==
      {
        reveal EncodeBlock();
        reveal DecodeBlock();
        reveal BV24ToSeq();
        reveal SeqToBV24();
        reveal IndexSeqToBV24();
        reveal BV24ToIndexSeq();
        assert d'[0] == IndexToChar(CharToIndex(s[0]));
        assert d'[1] == IndexToChar(CharToIndex(s[1]));
        assert d'[2] == IndexToChar(CharToIndex(s[2]));
      }
      [IndexToChar(CharToIndex(s[0])), IndexToChar(CharToIndex(s[1])), IndexToChar(CharToIndex(s[2])), '='];
    ==
      {
        CharToIndexToChar(s[0]);
        CharToIndexToChar(s[1]);
        CharToIndexToChar(s[2]);
      }
      s;
    }
  }

  opaque predicate Is2Padding(s: seq<char>)
  {
    |s| == 4 &&
    IsBase64Char(s[0]) &&
    IsBase64Char(s[1]) &&
    CharToIndex(s[1]) % 16 == 0 &&
    s[2] == '=' &&
    s[3] == '='
  }

  opaque function Decode2Padding(s: seq<char>): (b: seq<bv8>)
    requires Is2Padding(s)
    ensures |b| == 1
  {
    reveal Is2Padding();
    var d := DecodeBlock([CharToIndex(s[0]), CharToIndex(s[1]), 0, 0]);
    [d[0]]
  }

  opaque function Encode2Padding(b: seq<bv8>): (s: seq<char>)
    requires |b| == 1
    ensures |s| % 4 == 0
    ensures |s| == 4
  {
    var e := EncodeBlock([b[0], 0, 0]);
    IndexToCharIsBase64(e[0]);
    IndexToCharIsBase64(e[1]);
    [IndexToChar(e[0]), IndexToChar(e[1]), '=', '=']
  }

  lemma Encode2PaddingIs2Padding(b: seq<bv8>)
    requires |b| == 1
    ensures Is2Padding(Encode2Padding(b))
  {
    reveal IndexToChar();
    reveal Is2Padding();
    reveal CharToIndex();
    reveal Encode2Padding();
    reveal EncodeBlock();
    reveal BV24ToSeq();
    reveal SeqToBV24();
    reveal IndexSeqToBV24();
    reveal BV24ToIndexSeq();
    reveal IsBase64Char();
  }

  lemma DecodeEncodeBlock2Padding(b: seq<bv8>)
    requires |b| == 1
    ensures var e := EncodeBlock([b[0], 0, 0]); var d := DecodeBlock([e[0], e[1], 0, 0]); [d[0]] == b
  {
    reveal EncodeBlock();
    reveal DecodeBlock();
    reveal BV24ToSeq();
    reveal SeqToBV24();
    reveal IndexSeqToBV24();
    reveal BV24ToIndexSeq();
  }

  lemma EncodeDecode2Padding(b: seq<bv8>)
    requires |b| == 1
    ensures (Encode2PaddingIs2Padding(b); Decode2Padding(Encode2Padding(b)) == b)
  {
    Encode2PaddingIs2Padding(b);
    var e := EncodeBlock([b[0], 0, 0]);
    calc {
      Decode2Padding(Encode2Padding(b));
    ==
      {
        reveal Encode2Padding();
      }
      Decode2Padding([IndexToChar(e[0]), IndexToChar(e[1]), '=', '=']);
    ==
      {
        reveal Decode2Padding();
      }
      [DecodeBlock([CharToIndex(IndexToChar(e[0])), CharToIndex(IndexToChar(e[1])), 0, 0])[0]];
    ==
      {
        IndexToCharToIndex(e[0]);
        IndexToCharToIndex(e[1]);
      }
      [DecodeBlock([e[0], e[1], 0, 0])[0]];
    ==
      {
        DecodeEncodeBlock2Padding(b);
      }
      b;
    }
  }

  lemma DecodeEncode2Padding(s: seq<char>)
    requires Is2Padding(s)
    ensures Encode2Padding(Decode2Padding(s)) == s
  {
    reveal Is2Padding();
    var i := [CharToIndex(s[0]), CharToIndex(s[1]), 0, 0];
    var d := DecodeBlock(i);
    var e := EncodeBlock([d[0], 0, 0]);
    var d' := [IndexToChar(e[0]), IndexToChar(e[1]), '=', '='];
    calc {
      Encode2Padding(Decode2Padding(s));
    ==
      {
        reveal Decode2Padding();
      }
      Encode2Padding([d[0]]);
    ==
      {
        reveal Encode2Padding();
      }
      d';
    ==
      {
        reveal EncodeBlock();
        reveal DecodeBlock();
        reveal BV24ToSeq();
        reveal SeqToBV24();
        reveal IndexSeqToBV24();
        reveal BV24ToIndexSeq();
      }
      [IndexToChar(CharToIndex(s[0])), IndexToChar(CharToIndex(s[1])), '=', '='];
    ==
      {
        CharToIndexToChar(s[0]);
        CharToIndexToChar(s[1]);
      }
      s;
    }
  }

  opaque predicate IsBase64String(s: string)
  {
    reveal IsUnpaddedBase64String();
    reveal Is2Padding();
    var finalBlockStart := |s| - 4;
    |s| % 4 == 0 &&
    (IsUnpaddedBase64String(s) || (IsUnpaddedBase64String(s[..finalBlockStart]) && (Is1Padding(s[finalBlockStart..]) || Is2Padding(s[finalBlockStart..]))))
  }

  opaque function DecodeValid(s: seq<char>): (b: seq<bv8>)
    requires IsBase64String(s)
  {
    reveal IsUnpaddedBase64String();
    reveal IsBase64String();
    if s == [] then
      []
    else
      var finalBlockStart := |s| - 4; var prefix, suffix := s[..finalBlockStart], s[finalBlockStart..]; if Is1Padding(suffix) then DecodeUnpadded(prefix) + Decode1Padding(suffix) else if Is2Padding(suffix) then DecodeUnpadded(prefix) + Decode2Padding(suffix) else DecodeUnpadded(s)
  }

  lemma AboutDecodeValid(s: seq<char>, b: seq<bv8>)
    requires IsBase64String(s) && b == DecodeValid(s)
    ensures 4 <= |s| ==> var finalBlockStart := |s| - 4; var prefix, suffix := s[..finalBlockStart], s[finalBlockStart..]; (Is1Padding(suffix) && IsUnpaddedBase64String(prefix) <==> |b| % 3 == 2 && |b| > 1) && (Is2Padding(suffix) && IsUnpaddedBase64String(prefix) <==> |b| % 3 == 1 && |b| > 0) && (!Is1Padding(suffix) && !Is2Padding(suffix) && IsUnpaddedBase64String(s) <==> |b| % 3 == 0 && |b| > 1)
  {
    reveal DecodeValid();
    reveal IsUnpaddedBase64String();
    reveal IsBase64String();
    if 4 <= |s| {
      var finalBlockStart := |s| - 4;
      var prefix, suffix := s[..finalBlockStart], s[finalBlockStart..];
      if s == [] {
      } else if Is1Padding(suffix) {
        assert !Is2Padding(suffix) by {
          reveal IsBase64Char();
          reveal Is1Padding();
          reveal Is2Padding();
        }
        var x, y := DecodeUnpadded(prefix), Decode1Padding(suffix);
        assert b == x + y;
        assert |x| == |x| / 3 * 3 && |y| == 2 && |b| > 1 by {
          DecodeUnpaddedBounds(prefix);
        }
        Mod3(|x| / 3, |y|, |b|);
      } else if Is2Padding(suffix) {
        var x, y := DecodeUnpadded(prefix), Decode2Padding(suffix);
        assert b == x + y;
        assert |x| == |x| / 3 * 3 && |y| == 1 && |b| > 0 by {
          DecodeUnpaddedBounds(prefix);
        }
        Mod3(|x| / 3, |y|, |b|);
      } else {
        assert b == DecodeUnpadded(s);
        assert |b| % 3 == 0 && |b| > 1 by {
          DecodeUnpaddedBounds(s);
        }
      }
    }
  }

  lemma Mod3(x: nat, k: nat, n: nat)
    requires k < 3 && n == 3 * x + k
    ensures n % 3 == k
  {
  }

  opaque function DecodeBV(s: seq<char>): (b: Result<seq<bv8>, string>)
    ensures IsBase64String(s) ==> b.Success?
  {
    if IsBase64String(s) then
      Success(DecodeValid(s))
    else
      Failure("The encoding is malformed")
  }

  lemma DecodeBVFailure(s: seq<char>)
    ensures !IsBase64String(s) ==> DecodeBV(s).Failure?
  {
    reveal DecodeBV();
  }

  opaque ghost predicate StringIs7Bit(s: string)
  {
    forall c :: 
      c in s ==>
        c < 128 as char
  }

  lemma UnpaddedBase64StringIs7Bit(s: string)
    requires IsUnpaddedBase64String(s)
    ensures StringIs7Bit(s)
  {
    reveal IsUnpaddedBase64String();
    reveal IsBase64Char();
    reveal StringIs7Bit();
  }

  lemma Is7Bit1Padding(s: string)
    requires Is1Padding(s)
    ensures StringIs7Bit(s)
  {
    reveal IsBase64Char();
    reveal Is1Padding();
    reveal StringIs7Bit();
  }

  lemma Is7Bit2Padding(s: string)
    requires Is2Padding(s)
    ensures StringIs7Bit(s)
  {
    reveal IsBase64Char();
    reveal Is2Padding();
    reveal StringIs7Bit();
  }

  opaque function EncodeBV(b: seq<bv8>): (s: seq<char>)
  {
    if |b| % 3 == 0 then
      EncodeUnpaddedBounds(b);
      EncodeUnpadded(b)
    else if |b| % 3 == 1 then
      assert |b| >= 1;
      EncodeUnpaddedBounds(b[..|b| - 1]);
      var s1, s2 := EncodeUnpadded(b[..|b| - 1]), Encode2Padding(b[|b| - 1..]);
      s1 + s2
    else
      assert |b| % 3 == 2; assert |b| >= 2; EncodeUnpaddedBounds(b[..|b| - 2]); var s1, s2 := EncodeUnpadded(b[..|b| - 2]), Encode1Padding(b[|b| - 2..]); s1 + s2
  }

  lemma EncodeBVIsUnpadded(b: seq<bv8>)
    requires |b| % 3 == 0
    ensures EncodeBV(b) == EncodeUnpadded(b)
  {
    reveal EncodeBV();
  }

  lemma EncodeBVIs2Padded(b: seq<bv8>)
    requires |b| % 3 == 1
    ensures EncodeBV(b) == EncodeUnpadded(b[..|b| - 1]) + Encode2Padding(b[|b| - 1..])
  {
    reveal EncodeBV();
  }

  lemma EncodeBVIs1Padded(b: seq<bv8>)
    requires |b| % 3 == 2
    ensures EncodeBV(b) == EncodeUnpadded(b[..|b| - 2]) + Encode1Padding(b[|b| - 2..])
  {
    reveal EncodeBV();
  }

  lemma EncodeBVLengthCongruentToZeroMod4(b: seq<bv8>)
    ensures |EncodeBV(b)| % 4 == 0
  {
    reveal EncodeBV();
    if |b| % 3 == 0 {
      EncodeUnpaddedBounds(b);
    } else if |b| % 3 == 1 {
      EncodeUnpaddedBounds(b[..|b| - 1]);
    } else {
      EncodeUnpaddedBounds(b[..|b| - 2]);
    }
  }

  lemma EncodeBVIsBase64(b: seq<bv8>)
    ensures IsBase64String(EncodeBV(b))
  {
    reveal EncodeBV();
    reveal IsBase64String();
    EncodeBVLengthExact(b);
    if |EncodeBV(b)| < 4 {
      reveal IsUnpaddedBase64String();
    } else if |b| % 3 == 0 {
      EncodeUnpaddedBase64(b);
    } else if |b| % 3 == 1 {
      var bStart := b[..|b| - 1];
      var bEnd := b[|b| - 1..];
      EncodeUnpaddedBase64(bStart);
      Encode2PaddingIs2Padding(bEnd);
    } else {
      var bStart := b[..|b| - 2];
      var bEnd := b[|b| - 2..];
      EncodeUnpaddedBase64(bStart);
      Encode1PaddingIs1Padding(bEnd);
    }
  }

  lemma EncodeBVLengthExact(b: seq<bv8>)
    ensures var s := EncodeBV(b); (|b| % 3 == 0 ==> |s| == |b| / 3 * 4) && (|b| % 3 != 0 ==> |s| == |b| / 3 * 4 + 4)
  {
    reveal EncodeBV();
    reveal Is1Padding();
    reveal Is2Padding();
    var s := EncodeBV(b);
    if |b| % 3 == 0 {
      assert s == EncodeUnpadded(b);
      EncodeUnpaddedBounds(b);
      assert |s| == |b| / 3 * 4;
    } else if |b| % 3 == 1 {
      EncodeUnpaddedBounds(b[..|b| - 1]);
      assert s == EncodeUnpadded(b[..|b| - 1]) + Encode2Padding(b[|b| - 1..]);
      calc {
        |s|;
      ==
        |EncodeUnpadded(b[..|b| - 1])| + |Encode2Padding(b[|b| - 1..])|;
      ==
        {
          assert |Encode2Padding(b[|b| - 1..])| == 4;
        }
        |EncodeUnpadded(b[..|b| - 1])| + 4;
      ==
        {
          assert |EncodeUnpadded(b[..|b| - 1])| == |b[..|b| - 1]| / 3 * 4;
        }
        |b[..|b| - 1]| / 3 * 4 + 4;
      ==
        {
          assert |b[..|b| - 1]| == |b| - 1;
        }
        (|b| - 1) / 3 * 4 + 4;
      ==
        {
          assert (|b| - 1) / 3 == |b| / 3;
        }
        |b| / 3 * 4 + 4;
      }
    } else {
      EncodeUnpaddedBounds(b[..|b| - 2]);
      assert s == EncodeUnpadded(b[..|b| - 2]) + Encode1Padding(b[|b| - 2..]);
      Encode1PaddingIs1Padding(b[|b| - 2..]);
      calc {
        |s|;
      ==
        |EncodeUnpadded(b[..|b| - 2])| + |Encode1Padding(b[|b| - 2..])|;
      ==
        {
          assert |Encode1Padding(b[|b| - 2..])| == 4;
        }
        |EncodeUnpadded(b[..|b| - 2])| + 4;
      ==
        {
          assert |EncodeUnpadded(b[..|b| - 2])| == |b[..|b| - 2]| / 3 * 4;
        }
        |b[..|b| - 2]| / 3 * 4 + 4;
      ==
        {
          assert |b[..|b| - 2]| == |b| - 2;
        }
        (|b| - 2) / 3 * 4 + 4;
      ==
        {
          assert (|b| - 2) / 3 == |b| / 3;
        }
        |b| / 3 * 4 + 4;
      }
    }
  }

  lemma EncodeBVLengthBound(b: seq<bv8>)
    ensures var s := EncodeBV(b); |s| <= |b| / 3 * 4 + 4
  {
    EncodeBVLengthExact(b);
  }

  lemma SeqPartsMakeWhole<T>(s: seq<T>, i: nat)
    requires i <= |s|
    ensures s[..i] + s[i..] == s
  {
  }

  lemma DecodeValidEncodeEmpty(s: seq<char>)
    requires s == []
    ensures (reveal IsUnpaddedBase64String(); reveal IsBase64String(); EncodeBV(DecodeValid(s)) == s)
  {
    assert IsBase64String(s) by {
      reveal IsBase64String();
      reveal IsUnpaddedBase64String();
    }
    var b := DecodeValid(s);
    assert b == [] by {
      reveal DecodeValid();
    }
    assert EncodeBV(b) == [] by {
      reveal EncodeBV();
      reveal EncodeUnpadded();
      reveal EncodeRecursively();
      reveal FromIndicesToChars();
    }
  }

  lemma EncodeDecodeValidEmpty(b: seq<bv8>)
    requires b == []
    ensures (EncodeBVIsBase64(b); DecodeValid(EncodeBV(b)) == b)
  {
    assert EncodeBV(b) == [] by {
      reveal EncodeBV();
      reveal EncodeUnpadded();
      reveal EncodeRecursively();
      reveal FromIndicesToChars();
    }
    EncodeBVIsBase64(b);
    assert DecodeValid([]) == [] by {
      reveal DecodeValid();
    }
  }

  lemma DecodeValidEncodeUnpadded(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires !Is1Padding(s[|s| - 4..])
    requires !Is2Padding(s[|s| - 4..])
    ensures EncodeBV(DecodeValid(s)) == s
  {
    reveal EncodeBV();
    reveal DecodeValid();
    reveal IsBase64String();
    DecodeUnpaddedBounds(s);
    calc {
      EncodeBV(DecodeValid(s));
    ==
      EncodeBV(DecodeUnpadded(s));
    ==
      EncodeUnpadded(DecodeUnpadded(s));
    ==
      {
        DecodeEncodeUnpadded(s);
      }
      s;
    }
  }

  lemma EncodeDecodeValidUnpadded(b: seq<bv8>)
    requires |b| % 3 == 0
    requires b != []
    ensures var s := EncodeBV(b); IsUnpaddedBase64String(s) && |s| >= 4 && !Is1Padding(s[|s| - 4..]) && !Is2Padding(s[|s| - 4..]) && s == EncodeUnpadded(b)
  {
    EncodeUnpaddedBase64(b);
    EncodeUnpaddedBounds(b);
    var s := EncodeBV(b);
    assert s == EncodeUnpadded(b) by {
      EncodeBVIsUnpadded(b);
    }
    assert !Is1Padding(s[|s| - 4..]) by {
      EncodeUnpaddedNotPadded(b);
    }
    assert !Is2Padding(s[|s| - 4..]) by {
      EncodeUnpaddedNotPadded(b);
    }
  }

  lemma EncodeDecodeValid2Padded(b: seq<bv8>)
    requires |b| % 3 == 1
    ensures var s := EncodeBV(b); s == EncodeUnpadded(b[..|b| - 1]) + Encode2Padding(b[|b| - 1..]) && Is2Padding(s[|s| - 4..])
  {
    EncodeUnpaddedBase64(b[..|b| - 1]);
    EncodeUnpaddedBounds(b[..|b| - 1]);
    reveal EncodeBV();
    var s := EncodeBV(b);
    Encode2PaddingIs2Padding(b[|b| - 1..]);
    assert Is2Padding(s[|s| - 4..]);
  }

  lemma EncodeDecodeValid1Padded(b: seq<bv8>)
    requires |b| % 3 == 2
    ensures var s := EncodeBV(b); s == EncodeUnpadded(b[..|b| - 2]) + Encode1Padding(b[|b| - 2..]) && |s| >= 4 && IsUnpaddedBase64String(s[..|s| - 4]) && Is1Padding(s[|s| - 4..])
  {
    EncodeUnpaddedBase64(b[..|b| - 2]);
    EncodeUnpaddedBounds(b[..|b| - 2]);
    reveal EncodeBV();
    var s := EncodeBV(b);
    Encode1PaddingIs1Padding(b[|b| - 2..]);
    assert Is1Padding(s[|s| - 4..]);
  }

  lemma DecodeValidUnpaddedPartialFrom1PaddedSeq(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is1Padding(s[|s| - 4..])
    ensures (reveal IsUnpaddedBase64String(); reveal IsBase64String(); reveal DecodeValid(); DecodeValid(s)[..|DecodeValid(s)| - 2] == DecodeUnpadded(s[..|s| - 4]))
  {
    reveal IsBase64String();
    reveal DecodeValid();
  }

  lemma DecodeValid1PaddedPartialFrom1PaddedSeq(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is1Padding(s[|s| - 4..])
    ensures (reveal DecodeValid(); DecodeValid(s)[|DecodeValid(s)| - 2..] == Decode1Padding(s[|s| - 4..]))
  {
    reveal DecodeValid();
  }

  lemma DecodeValid1PaddingLengthMod3(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is1Padding(s[|s| - 4..])
    ensures |DecodeValid(s)| % 3 == 2
  {
    assert IsUnpaddedBase64String(s[..|s| - 4]) by {
      UnpaddedBase64Prefix(s);
    }
    AboutDecodeValid(s, DecodeValid(s));
  }

  lemma {:rlimit 12000} DecodeValidEncode1Padding(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is1Padding(s[|s| - 4..])
    ensures EncodeBV(DecodeValid(s)) == s
  {
    assert |DecodeValid(s)| % 3 == 2 by {
      DecodeValid1PaddingLengthMod3(s);
    }
    calc {
      EncodeBV(DecodeValid(s));
    ==
      {
        reveal EncodeBV();
      }
      EncodeUnpadded(DecodeValid(s)[..|DecodeValid(s)| - 2]) + Encode1Padding(DecodeValid(s)[|DecodeValid(s)| - 2..]);
    ==
      {
        DecodeValidUnpaddedPartialFrom1PaddedSeq(s);
        reveal IsBase64String();
        reveal IsUnpaddedBase64String();
      }
      EncodeUnpadded(DecodeUnpadded(s[..|s| - 4])) + Encode1Padding(DecodeValid(s)[|DecodeValid(s)| - 2..]);
    ==
      {
        reveal IsUnpaddedBase64String();
        DecodeEncodeUnpadded(s[..|s| - 4]);
      }
      s[..|s| - 4] + Encode1Padding(DecodeValid(s)[|DecodeValid(s)| - 2..]);
    ==
      {
        DecodeValid1PaddedPartialFrom1PaddedSeq(s);
      }
      s[..|s| - 4] + Encode1Padding(Decode1Padding(s[|s| - 4..]));
    ==
      {
        DecodeEncode1Padding(s[|s| - 4..]);
      }
      s[..|s| - 4] + s[|s| - 4..];
    ==
      {
        SeqPartsMakeWhole(s, |s| - 4);
      }
      s;
    }
  }

  lemma DecodeValidPartialsFrom2PaddedSeq(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is2Padding(s[|s| - 4..])
    ensures (reveal IsUnpaddedBase64String(); reveal DecodeValid(); reveal IsBase64String(); var b := DecodeValid(s); b[..|b| - 1] == DecodeUnpadded(s[..|s| - 4]) && b[|b| - 1..] == Decode2Padding(s[|s| - 4..]))
  {
    reveal IsUnpaddedBase64String();
    reveal IsBase64String();
    reveal DecodeValid();
    AboutDecodeValid(s, DecodeValid(s));
    assert Is2Padding(s[|s| - 4..]);
  }

  lemma DecodeValidPartialsFrom1PaddedSeq(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is1Padding(s[|s| - 4..])
    ensures (reveal IsUnpaddedBase64String(); reveal DecodeValid(); reveal IsBase64String(); var b := DecodeValid(s); b[..|b| - 2] == DecodeUnpadded(s[..|s| - 4]) && b[|b| - 2..] == Decode1Padding(s[|s| - 4..]))
  {
    reveal IsUnpaddedBase64String();
    reveal DecodeValid();
    reveal IsBase64String();
    AboutDecodeValid(s, DecodeValid(s));
  }

  lemma UnpaddedBase64Prefix(s: string)
    requires IsBase64String(s)
    requires |s| >= 4
    ensures IsUnpaddedBase64String(s[..|s| - 4])
  {
    reveal IsBase64String();
    reveal IsUnpaddedBase64String();
  }

  lemma DecodeValid2PaddingLengthMod3(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is2Padding(s[|s| - 4..])
    ensures |DecodeValid(s)| % 3 == 1
  {
    assert IsUnpaddedBase64String(s[..|s| - 4]) by {
      UnpaddedBase64Prefix(s);
    }
    AboutDecodeValid(s, DecodeValid(s));
  }

  lemma DecodeValidEncode2Padding(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is2Padding(s[|s| - 4..])
    ensures EncodeBV(DecodeValid(s)) == s
  {
    assert |DecodeValid(s)| % 3 == 1 by {
      DecodeValid2PaddingLengthMod3(s);
    }
    calc {
      EncodeBV(DecodeValid(s));
    ==
      {
        reveal EncodeBV();
      }
      EncodeUnpadded(DecodeValid(s)[..|DecodeValid(s)| - 1]) + Encode2Padding(DecodeValid(s)[|DecodeValid(s)| - 1..]);
    ==
      {
        DecodeValidPartialsFrom2PaddedSeq(s);
        reveal IsUnpaddedBase64String();
        reveal IsBase64String();
      }
      EncodeUnpadded(DecodeUnpadded(s[..|s| - 4])) + Encode2Padding(DecodeValid(s)[|DecodeValid(s)| - 1..]);
    ==
      {
        reveal IsBase64String();
        DecodeEncodeUnpadded(s[..|s| - 4]);
      }
      s[..|s| - 4] + Encode2Padding(DecodeValid(s)[|DecodeValid(s)| - 1..]);
    ==
      {
        DecodeValidPartialsFrom2PaddedSeq(s);
      }
      s[..|s| - 4] + Encode2Padding(Decode2Padding(s[|s| - 4..]));
    ==
      {
        DecodeEncode2Padding(s[|s| - 4..]);
      }
      s[..|s| - 4] + s[|s| - 4..];
    ==
      {
        SeqPartsMakeWhole(s, |s| - 4);
      }
      s;
    }
  }

  lemma DecodeValidEncode(s: seq<char>)
    requires IsBase64String(s)
    ensures EncodeBV(DecodeValid(s)) == s
  {
    reveal IsBase64String();
    if s == [] {
      calc {
        EncodeBV(DecodeValid(s));
      ==
        {
          DecodeValidEncodeEmpty(s);
        }
        s;
      }
    } else if |s| >= 4 && Is1Padding(s[|s| - 4..]) {
      calc {
        EncodeBV(DecodeValid(s));
      ==
        {
          DecodeValidEncode1Padding(s);
        }
        s;
      }
    } else if |s| >= 4 && Is2Padding(s[|s| - 4..]) {
      calc {
        EncodeBV(DecodeValid(s));
      ==
        {
          DecodeValidEncode2Padding(s);
        }
        s;
      }
    } else {
      calc {
        EncodeBV(DecodeValid(s));
      ==
        {
          DecodeValidEncodeUnpadded(s);
        }
        s;
      }
    }
  }

  lemma EncodeDecodeValid(b: seq<bv8>)
    ensures (EncodeBVIsBase64(b); DecodeValid(EncodeBV(b)) == b)
  {
    EncodeBVIsBase64(b);
    var s := EncodeBV(b);
    if b == [] {
      calc {
        DecodeValid(EncodeBV(b));
      ==
        {
          EncodeDecodeValidEmpty(b);
        }
        b;
      }
    } else if |b| % 3 == 0 {
      calc {
        DecodeValid(EncodeBV(b));
      ==
        {
          EncodeBVIsUnpadded(b);
        }
        DecodeValid(EncodeUnpadded(b));
      ==
        {
          EncodeDecodeValidUnpadded(b);
          reveal DecodeValid();
        }
        DecodeUnpadded(EncodeUnpadded(b));
      ==
        {
          EncodeDecodeUnpadded(b);
        }
        b;
      }
    } else if |b| % 3 == 1 {
      EncodeDecodeValid2Padded(b);
      var prefix := b[..|b| - 1];
      var suffix := b[|b| - 1..];
      EncodeUnpaddedBase64(prefix);
      calc {
        DecodeValid(EncodeBV(b));
      ==
        {
          reveal EncodeBV();
        }
        DecodeValid(EncodeUnpadded(prefix) + Encode2Padding(suffix));
      ==
        {
          reveal DecodeValid();
          DecodeValidPartialsFrom2PaddedSeq(s);
        }
        DecodeUnpadded(EncodeUnpadded(prefix)) + Decode2Padding(Encode2Padding(suffix));
      ==
        {
          EncodeDecodeUnpadded(prefix);
          EncodeDecode2Padding(suffix);
        }
        prefix + suffix;
      ==
        b;
      }
    } else if |b| % 3 == 2 {
      EncodeDecodeValid1Padded(b);
      var prefix := b[..|b| - 2];
      var suffix := b[|b| - 2..];
      EncodeUnpaddedBase64(prefix);
      calc {
        DecodeValid(EncodeBV(b));
      ==
        {
          reveal EncodeBV();
        }
        DecodeValid(EncodeUnpadded(prefix) + Encode1Padding(suffix));
      ==
        {
          reveal DecodeValid();
          DecodeValidPartialsFrom1PaddedSeq(s);
        }
        DecodeUnpadded(EncodeUnpadded(prefix)) + Decode1Padding(Encode1Padding(suffix));
      ==
        {
          EncodeDecodeUnpadded(prefix);
          EncodeDecode1Padding(suffix);
        }
        prefix + suffix;
      ==
        b;
      }
    }
  }

  lemma DecodeEncodeBV(s: seq<char>)
    requires IsBase64String(s)
    ensures EncodeBV(DecodeBV(s).value) == s
  {
    reveal DecodeBV();
    calc {
      EncodeBV(DecodeBV(s).value);
    ==
      {
        DecodeValidEncode(s);
      }
      s;
    }
  }

  lemma EncodeDecodeBV(b: seq<bv8>)
    ensures DecodeBV(EncodeBV(b)) == Success(b)
  {
    reveal DecodeBV();
    EncodeBVIsBase64(b);
    calc {
      DecodeBV(EncodeBV(b));
    ==
      {
        assert IsBase64String(EncodeBV(b));
      }
      Success(DecodeValid(EncodeBV(b)));
    ==
      {
        EncodeDecodeValid(b);
      }
      Success(b);
    }
  }

  opaque function UInt8sToBVs(u: seq<uint8>): (r: seq<bv8>)
    ensures |r| == |u|
    ensures forall i :: 0 <= i < |u| ==> r[i] == u[i] as bv8
  {
    seq(|u|, i requires 0 <= i < |u| => u[i] as bv8)
  }

  opaque function BVsToUInt8s(b: seq<bv8>): (r: seq<uint8>)
    ensures |r| == |b|
    ensures forall i :: 0 <= i < |b| ==> r[i] == b[i] as uint8
  {
    seq(|b|, i requires 0 <= i < |b| => b[i] as uint8)
  }

  lemma {:rlimit 8000} UInt8sToBVsToUInt8s(u: seq<uint8>)
    ensures BVsToUInt8s(UInt8sToBVs(u)) == u
  {
    var b := UInt8sToBVs(u);
    assert |b| == |u|;
    var u' := BVsToUInt8s(b);
    assert |u'| == |b|;
  }

  lemma BVsToUInt8sToBVs(b: seq<bv8>)
    ensures UInt8sToBVs(BVsToUInt8s(b)) == b
  {
    var u := BVsToUInt8s(b);
    assert |b| == |u|;
    var b' := UInt8sToBVs(u);
    assert |b'| == |u|;
  }

  opaque function Encode(u: seq<uint8>): seq<char>
  {
    EncodeBV(UInt8sToBVs(u))
  }

  opaque function Decode(s: seq<char>): (b: Result<seq<uint8>, string>)
    ensures IsBase64String(s) ==> b.Success?
  {
    if IsBase64String(s) then
      var b := DecodeValid(s);
      Success(BVsToUInt8s(b))
    else
      Failure("The encoding is malformed")
  }

  lemma EncodeDecode(b: seq<uint8>)
    ensures Decode(Encode(b)) == Success(b)
  {
    var bvs := UInt8sToBVs(b);
    var s := EncodeBV(bvs);
    assert Encode(b) == s by {
      reveal Encode();
    }
    assert IsBase64String(s) by {
      EncodeBVIsBase64(bvs);
    }
    var b' := DecodeValid(s);
    assert b' == bvs by {
      EncodeDecodeValid(bvs);
    }
    var us := BVsToUInt8s(b');
    assert Decode(s) == Success(us) by {
      reveal Decode();
    }
    assert b' == bvs;
    assert b == us by {
      UInt8sToBVsToUInt8s(b);
    }
  }

  lemma DecodeEncode(s: seq<char>)
    requires IsBase64String(s)
    ensures Encode(Decode(s).value) == s
  {
    var b := DecodeValid(s);
    var u := BVsToUInt8s(b);
    assert Decode(s) == Success(u) by {
      reveal Decode();
    }
    var s' := EncodeBV(UInt8sToBVs(u));
    assert s' == Encode(u) by {
      reveal Encode();
    }
    assert UInt8sToBVs(BVsToUInt8s(b)) == b by {
      BVsToUInt8sToBVs(b);
    }
    assert s == s' by {
      DecodeValidEncode(s);
    }
  }

  import opened Wrappers

  import opened BoundedInts

  export
    reveals IsBase64Char, index, CharToIndex, IndexToChar, IsBase64String, IsUnpaddedBase64String, Is1Padding, Is2Padding
    provides Encode, Decode, EncodeBV, DecodeBV, EncodeDecode, DecodeEncode, EncodeDecodeBV, DecodeEncodeBV, BoundedInts, Wrappers


  export Internals
    reveals *


  type index = bv6
}

module DafnyStdLibs.BoundedInts {
  const TWO_TO_THE_0: int := 1
  const TWO_TO_THE_1: int := 2
  const TWO_TO_THE_2: int := 4
  const TWO_TO_THE_4: int := 16
  const TWO_TO_THE_5: int := 32
  const TWO_TO_THE_7: int := 128
  const TWO_TO_THE_8: int := 256
  const TWO_TO_THE_15: int := 32768
  const TWO_TO_THE_16: int := 65536
  const TWO_TO_THE_24: int := 16777216
  const TWO_TO_THE_31: int := 2147483648
  const TWO_TO_THE_32: int := 4294967296
  const TWO_TO_THE_40: int := 1099511627776
  const TWO_TO_THE_48: int := 281474976710656
  const TWO_TO_THE_56: int := 72057594037927936
  const TWO_TO_THE_63: int := 9223372036854775808
  const TWO_TO_THE_64: int := 18446744073709551616
  const TWO_TO_THE_127: int := 170141183460469231731687303715884105728
  const TWO_TO_THE_128: int := 340282366920938463463374607431768211456
  const TWO_TO_THE_256: int := 115792089237316195423570985008687907853269984665640564039457584007913129639936
  const TWO_TO_THE_512: int := 13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084096

  newtype uint8 = x: int
    | 0 <= x < TWO_TO_THE_8

  newtype uint16 = x: int
    | 0 <= x < TWO_TO_THE_16

  newtype uint32 = x: int
    | 0 <= x < TWO_TO_THE_32

  newtype uint64 = x: int
    | 0 <= x < TWO_TO_THE_64

  newtype uint128 = x: int
    | 0 <= x < TWO_TO_THE_128

  newtype int8 = x: int
    | -TWO_TO_THE_7 <= x < TWO_TO_THE_7

  newtype int16 = x: int
    | -TWO_TO_THE_15 <= x < TWO_TO_THE_15

  newtype int32 = x: int
    | -TWO_TO_THE_31 <= x < TWO_TO_THE_31

  newtype int64 = x: int
    | -TWO_TO_THE_63 <= x < TWO_TO_THE_63

  newtype int128 = x: int
    | -TWO_TO_THE_127 <= x < TWO_TO_THE_127

  newtype nat8 = x: int
    | 0 <= x < TWO_TO_THE_7

  newtype nat16 = x: int
    | 0 <= x < TWO_TO_THE_15

  newtype nat32 = x: int
    | 0 <= x < TWO_TO_THE_31

  newtype nat64 = x: int
    | 0 <= x < TWO_TO_THE_63

  newtype nat128 = x: int
    | 0 <= x < TWO_TO_THE_127
}

module DafnyStdLibs.Collections.Arrays {
  method BinarySearch<T>(a: array<T>, key: T, less: (T, T) -> bool)
      returns (r: Option<nat>)
    requires SortedBy((x, y) => less(x, y) || x == y, a[..])
    requires StrictTotalOrdering(less)
    ensures r.Some? ==> r.value < a.Length && a[r.value] == key
    ensures r.None? ==> key !in a[..]
  {
    var lo, hi: nat := 0, a.Length;
    while lo < hi
      invariant 0 <= lo <= hi <= a.Length
      invariant key !in a[..lo] && key !in a[hi..]
      invariant a[..] == old(a[..])
    {
      var mid := (lo + hi) / 2;
      if less(key, a[mid]) {
        hi := mid;
      } else if less(a[mid], key) {
        lo := mid + 1;
      } else {
        return Some(mid);
      }
    }
    return None;
  }

  import opened Wrappers

  import opened Relations

  import opened Seqs
}

module DafnyStdLibs.Collections {
}

module DafnyStdLibs.Collections.Imaps {
  function Get<X, Y>(m: imap<X, Y>, x: X): Option<Y>
  {
    if x in m then
      Some(m[x])
    else
      None
  }

  ghost function {:opaque} RemoveKeys<X, Y>(m: imap<X, Y>, xs: iset<X>): (m': imap<X, Y>)
    ensures forall x {:trigger m'[x]} :: x in m && x !in xs ==> x in m' && m'[x] == m[x]
    ensures forall x {:trigger x in m'} :: x in m' ==> x in m && x !in xs
    ensures m'.Keys == m.Keys - xs
  {
    imap x | x in m && x !in xs :: m[x]
  }

  ghost function {:opaque} RemoveKey<X, Y>(m: imap<X, Y>, x: X): (m': imap<X, Y>)
    ensures m' == RemoveKeys(m, iset{x})
    ensures forall x' {:trigger m'[x']} :: x' in m' ==> m'[x'] == m[x']
  {
    imap i | i in m && i != x :: m[i]
  }

  ghost function {:opaque} Restrict<X, Y>(m: imap<X, Y>, xs: iset<X>): (m': imap<X, Y>)
    ensures m' == RemoveKeys(m, m.Keys - xs)
  {
    imap x | x in xs && x in m :: m[x]
  }

  ghost predicate EqualOnKey<X, Y>(m: imap<X, Y>, m': imap<X, Y>, x: X)
  {
    (x !in m && x !in m') || (x in m && x in m' && m[x] == m'[x])
  }

  ghost predicate IsSubset<X, Y>(m: imap<X, Y>, m': imap<X, Y>)
  {
    m.Keys <= m'.Keys &&
    forall x {:trigger EqualOnKey(m, m', x)} {:trigger x in m} :: 
      x in m ==>
        EqualOnKey(m, m', x)
  }

  ghost function {:opaque} Union<X, Y>(m: imap<X, Y>, m': imap<X, Y>): (r: imap<X, Y>)
    ensures r.Keys == m.Keys + m'.Keys
    ensures forall x {:trigger r[x]} :: x in m' ==> r[x] == m'[x]
    ensures forall x {:trigger r[x]} :: x in m && x !in m' ==> r[x] == m[x]
  {
    m + m'
  }

  ghost predicate {:opaque} Injective<X, Y>(m: imap<X, Y>)
  {
    forall x, x' {:trigger m[x], m[x']} :: 
      x != x' &&
      x in m &&
      x' in m ==>
        m[x] != m[x']
  }

  ghost function {:opaque} Invert<X, Y>(m: imap<X, Y>): imap<Y, X>
  {
    imap y | y in m.Values :: var x :| x in m.Keys && m[x] == y; x
  }

  lemma LemmaInvertIsInjective<X, Y>(m: imap<X, Y>)
    ensures Injective(Invert(m))
  {
    reveal Injective();
    reveal Invert();
  }

  ghost predicate {:opaque} Total<X(!new), Y>(m: imap<X, Y>)
  {
    forall i {:trigger m[i]} {:trigger i in m} :: 
      i in m
  }

  ghost predicate {:opaque} Monotonic(m: imap<int, int>)
  {
    forall x, x' {:trigger m[x], m[x']} :: 
      x in m &&
      x' in m &&
      x <= x' ==>
        m[x] <= m[x']
  }

  ghost predicate {:opaque} MonotonicFrom(m: imap<int, int>, start: int)
  {
    forall x, x' {:trigger m[x], m[x']} :: 
      x in m &&
      x' in m &&
      start <= x <= x' ==>
        m[x] <= m[x']
  }

  import opened Wrappers
}

module DafnyStdLibs.Collections.Isets {
  lemma LemmaSubset<T>(x: iset<T>, y: iset<T>)
    requires forall e {:trigger e in y} :: e in x ==> e in y
    ensures x <= y
  {
  }

  ghost function {:opaque} Map<X(!new), Y>(xs: iset<X>, f: X --> Y): (ys: iset<Y>)
    requires forall x {:trigger f.requires(x)} :: f.requires(x)
    requires Injective(f)
    reads f.reads
    ensures forall x {:trigger f(x)} :: x in xs <==> f(x) in ys
  {
    var ys := iset x | x in xs :: f(x);
    ys
  }

  ghost function {:opaque} Filter<X(!new)>(xs: iset<X>, f: X ~> bool): (ys: iset<X>)
    requires forall x {:trigger f.requires(x)} {:trigger x in xs} :: x in xs ==> f.requires(x)
    reads set x, o | x in xs && o in f.reads(x) :: o
    ensures forall y {:trigger f(y)} {:trigger y in xs} :: y in ys <==> y in xs && f(y)
  {
    var ys := iset x | x in xs && f(x);
    ys
  }

  import opened Functions

  import opened Relations
}

module DafnyStdLibs.Collections.Maps {
  function Get<X, Y>(m: map<X, Y>, x: X): Option<Y>
  {
    if x in m then
      Some(m[x])
    else
      None
  }

  function {:opaque} ToImap<X, Y>(m: map<X, Y>): (m': imap<X, Y>)
    ensures forall x {:trigger m'[x]} :: x in m ==> x in m' && m'[x] == m[x]
    ensures forall x {:trigger x in m'} :: x in m' ==> x in m
  {
    imap x | x in m :: m[x]
  }

  function {:opaque} RemoveKeys<X, Y>(m: map<X, Y>, xs: set<X>): (m': map<X, Y>)
    ensures forall x {:trigger m'[x]} :: x in m && x !in xs ==> x in m' && m'[x] == m[x]
    ensures forall x {:trigger x in m'} :: x in m' ==> x in m && x !in xs
    ensures m'.Keys == m.Keys - xs
  {
    m - xs
  }

  function {:opaque} Remove<X, Y>(m: map<X, Y>, x: X): (m': map<X, Y>)
    ensures m' == RemoveKeys(m, {x})
    ensures |m'.Keys| <= |m.Keys|
    ensures x in m ==> |m'| == |m| - 1
    ensures x !in m ==> |m'| == |m|
  {
    var m' := map x' | x' in m && x' != x :: m[x'];
    assert m'.Keys == m.Keys - {x};
    m'
  }

  function {:opaque} Restrict<X, Y>(m: map<X, Y>, xs: set<X>): (m': map<X, Y>)
    ensures m' == RemoveKeys(m, m.Keys - xs)
  {
    map x | x in xs && x in m :: m[x]
  }

  ghost predicate EqualOnKey<X, Y>(m: map<X, Y>, m': map<X, Y>, x: X)
  {
    (x !in m && x !in m') || (x in m && x in m' && m[x] == m'[x])
  }

  ghost predicate IsSubset<X, Y>(m: map<X, Y>, m': map<X, Y>)
  {
    m.Keys <= m'.Keys &&
    forall x {:trigger EqualOnKey(m, m', x)} {:trigger x in m} :: 
      x in m ==>
        EqualOnKey(m, m', x)
  }

  function {:opaque} Union<X, Y>(m: map<X, Y>, m': map<X, Y>): (r: map<X, Y>)
    ensures r.Keys == m.Keys + m'.Keys
    ensures forall x {:trigger r[x]} :: x in m' ==> r[x] == m'[x]
    ensures forall x {:trigger r[x]} :: x in m && x !in m' ==> r[x] == m[x]
  {
    m + m'
  }

  lemma LemmaDisjointUnionSize<X, Y>(m: map<X, Y>, m': map<X, Y>)
    requires m.Keys !! m'.Keys
    ensures |Union(m, m')| == |m| + |m'|
  {
    var u := Union(m, m');
    assert |u.Keys| == |m.Keys| + |m'.Keys|;
  }

  ghost predicate {:opaque} Injective<X, Y>(m: map<X, Y>)
  {
    forall x, x' {:trigger m[x], m[x']} :: 
      x != x' &&
      x in m &&
      x' in m ==>
        m[x] != m[x']
  }

  ghost function {:opaque} Invert<X, Y>(m: map<X, Y>): map<Y, X>
  {
    map y | y in m.Values :: var x :| x in m.Keys && m[x] == y; x
  }

  lemma LemmaInvertIsInjective<X, Y>(m: map<X, Y>)
    ensures Injective(Invert(m))
  {
    reveal Injective();
    reveal Invert();
  }

  ghost predicate {:opaque} Total<X(!new), Y>(m: map<X, Y>)
  {
    forall i {:trigger m[i]} {:trigger i in m} :: 
      i in m
  }

  ghost predicate {:opaque} Monotonic(m: map<int, int>)
  {
    forall x, x' {:trigger m[x], m[x']} :: 
      x in m &&
      x' in m &&
      x <= x' ==>
        m[x] <= m[x']
  }

  ghost predicate {:opaque} MonotonicFrom(m: map<int, int>, start: int)
  {
    forall x, x' {:trigger m[x], m[x']} :: 
      x in m &&
      x' in m &&
      start <= x <= x' ==>
        m[x] <= m[x']
  }

  import opened Wrappers
}

module DafnyStdLibs.Collections.Seqs {
  function First<T>(xs: seq<T>): T
    requires |xs| > 0
  {
    xs[0]
  }

  function DropFirst<T>(xs: seq<T>): seq<T>
    requires |xs| > 0
  {
    xs[1..]
  }

  function Last<T>(xs: seq<T>): T
    requires |xs| > 0
  {
    xs[|xs| - 1]
  }

  function DropLast<T>(xs: seq<T>): seq<T>
    requires |xs| > 0
  {
    xs[..|xs| - 1]
  }

  lemma LemmaLast<T>(xs: seq<T>)
    requires |xs| > 0
    ensures DropLast(xs) + [Last(xs)] == xs
  {
  }

  lemma LemmaAppendLast<T>(xs: seq<T>, ys: seq<T>)
    requires 0 < |ys|
    ensures Last(xs + ys) == Last(ys)
  {
  }

  lemma LemmaConcatIsAssociative<T>(xs: seq<T>, ys: seq<T>, zs: seq<T>)
    ensures xs + (ys + zs) == xs + ys + zs
  {
  }

  ghost predicate IsPrefix<T>(xs: seq<T>, ys: seq<T>)
    ensures IsPrefix(xs, ys) ==> |xs| <= |ys| && xs == ys[..|xs|]
  {
    xs <= ys
  }

  ghost predicate IsSuffix<T>(xs: seq<T>, ys: seq<T>)
  {
    |xs| <= |ys| &&
    xs == ys[|ys| - |xs|..]
  }

  lemma LemmaSplitAt<T>(xs: seq<T>, pos: nat)
    requires pos < |xs|
    ensures xs[..pos] + xs[pos..] == xs
  {
  }

  lemma LemmaElementFromSlice<T>(xs: seq<T>, xs': seq<T>, a: int, b: int, pos: nat)
    requires 0 <= a <= pos < b <= |xs|
    requires xs' == xs[a .. b]
    ensures pos - a < |xs'|
    ensures xs'[pos - a] == xs[pos]
  {
  }

  lemma LemmaSliceOfSlice<T>(xs: seq<T>, s1: int, e1: int, s2: int, e2: int)
    requires 0 <= s1 <= e1 <= |xs|
    requires 0 <= s2 <= e2 <= e1 - s1
    ensures xs[s1 .. e1][s2 .. e2] == xs[s1 + s2 .. s1 + e2]
  {
    var r1 := xs[s1 .. e1];
    var r2 := r1[s2 .. e2];
    var r3 := xs[s1 + s2 .. s1 + e2];
    assert |r2| == |r3|;
    forall i {:trigger r2[i], r3[i]} | 0 <= i < |r2|
      ensures r2[i] == r3[i]
    {
    }
  }

  method ToArray<T>(xs: seq<T>) returns (a: array<T>)
    ensures fresh(a)
    ensures a.Length == |xs|
    ensures forall i :: 0 <= i < |xs| ==> a[i] == xs[i]
  {
    a := new T[|xs|] (i requires 0 <= i < |xs| => xs[i]);
  }

  function {:opaque} ToSet<T>(xs: seq<T>): set<T>
  {
    set x: T | x in xs
  }

  lemma LemmaCardinalityOfSet<T>(xs: seq<T>)
    ensures |ToSet(xs)| <= |xs|
  {
    reveal ToSet();
    if |xs| == 0 {
    } else {
      assert ToSet(xs) == ToSet(DropLast(xs)) + {Last(xs)};
      LemmaCardinalityOfSet(DropLast(xs));
    }
  }

  lemma LemmaCardinalityOfEmptySetIs0<T>(xs: seq<T>)
    ensures |ToSet(xs)| == 0 <==> |xs| == 0
  {
    reveal ToSet();
    if |xs| != 0 {
      assert xs[0] in ToSet(xs);
    }
  }

  ghost predicate {:opaque} HasNoDuplicates<T>(xs: seq<T>)
  {
    forall i, j {:trigger xs[i], xs[j]} :: 
      0 <= i < |xs| &&
      0 <= j < |xs| &&
      i != j ==>
        xs[i] != xs[j]
  }

  lemma {:timeLimitMultiplier 3} LemmaNoDuplicatesInConcat<T>(xs: seq<T>, ys: seq<T>)
    requires HasNoDuplicates(xs)
    requires HasNoDuplicates(ys)
    requires multiset(xs) !! multiset(ys)
    ensures HasNoDuplicates(xs + ys)
  {
    reveal HasNoDuplicates();
    var zs := xs + ys;
    if |zs| > 1 {
      assert forall i {:trigger zs[i]} :: 0 <= i < |xs| ==> zs[i] in multiset(xs);
      assert forall j {:trigger zs[j]} :: |xs| <= j < |zs| ==> zs[j] in multiset(ys);
      assert forall i, j {:trigger zs[i], zs[j]} :: i != j && 0 <= i < |xs| && |xs| <= j < |zs| ==> zs[i] != zs[j];
    }
  }

  lemma LemmaCardinalityOfSetNoDuplicates<T>(xs: seq<T>)
    requires HasNoDuplicates(xs)
    ensures |ToSet(xs)| == |xs|
  {
    reveal HasNoDuplicates();
    reveal ToSet();
    if |xs| == 0 {
    } else {
      LemmaCardinalityOfSetNoDuplicates(DropLast(xs));
      assert ToSet(xs) == ToSet(DropLast(xs)) + {Last(xs)};
    }
  }

  lemma LemmaNoDuplicatesCardinalityOfSet<T>(xs: seq<T>)
    requires |ToSet(xs)| == |xs|
    ensures HasNoDuplicates(xs)
  {
    reveal HasNoDuplicates();
    reveal ToSet();
    if |xs| == 0 {
    } else {
      assert xs == [First(xs)] + DropFirst(xs);
      assert ToSet(xs) == {First(xs)} + ToSet(DropFirst(xs));
      if First(xs) in DropFirst(xs) {
        assert ToSet(xs) == ToSet(DropFirst(xs));
        LemmaCardinalityOfSet(DropFirst(xs));
      } else {
        assert |ToSet(xs)| == 1 + |ToSet(DropFirst(xs))|;
        LemmaNoDuplicatesCardinalityOfSet(DropFirst(xs));
      }
    }
  }

  lemma LemmaMultisetHasNoDuplicates<T>(xs: seq<T>)
    requires HasNoDuplicates(xs)
    ensures forall x {:trigger multiset(xs)[x]} | x in multiset(xs) :: multiset(xs)[x] == 1
  {
    if |xs| == 0 {
    } else {
      assert xs == DropLast(xs) + [Last(xs)];
      assert Last(xs) !in DropLast(xs) by {
        reveal HasNoDuplicates();
      }
      assert HasNoDuplicates(DropLast(xs)) by {
        reveal HasNoDuplicates();
      }
      LemmaMultisetHasNoDuplicates(DropLast(xs));
    }
  }

  function {:opaque} IndexOf<T(==)>(xs: seq<T>, v: T): (i: nat)
    requires v in xs
    ensures i < |xs| && xs[i] == v
    ensures forall j {:trigger xs[j]} :: 0 <= j < i ==> xs[j] != v
  {
    if xs[0] == v then
      0
    else
      1 + IndexOf(xs[1..], v)
  }

  function {:opaque} IndexOfOption<T(==)>(xs: seq<T>, v: T): (o: Option<nat>)
    ensures if o.Some? then o.value < |xs| && xs[o.value] == v && forall j {:trigger xs[j]} :: 0 <= j < o.value ==> xs[j] != v else v !in xs
  {
    if |xs| == 0 then
      None()
    else if xs[0] == v then
      Some(0)
    else
      var o' := IndexOfOption(xs[1..], v); if o'.Some? then Some(o'.value + 1) else None()
  }

  function {:opaque} LastIndexOf<T(==)>(xs: seq<T>, v: T): (i: nat)
    requires v in xs
    ensures i < |xs| && xs[i] == v
    ensures forall j {:trigger xs[j]} :: i < j < |xs| ==> xs[j] != v
  {
    if xs[|xs| - 1] == v then
      |xs| - 1
    else
      LastIndexOf(xs[..|xs| - 1], v)
  }

  function {:opaque} LastIndexOfOption<T(==)>(xs: seq<T>, v: T): (o: Option<nat>)
    ensures if o.Some? then o.value < |xs| && xs[o.value] == v && forall j {:trigger xs[j]} :: o.value < j < |xs| ==> xs[j] != v else v !in xs
  {
    if |xs| == 0 then
      None()
    else if xs[|xs| - 1] == v then
      Some(|xs| - 1)
    else
      LastIndexOfOption(xs[..|xs| - 1], v)
  }

  function {:opaque} Remove<T>(xs: seq<T>, pos: nat): (ys: seq<T>)
    requires pos < |xs|
    ensures |ys| == |xs| - 1
    ensures forall i {:trigger ys[i], xs[i]} | 0 <= i < pos :: ys[i] == xs[i]
    ensures forall i {:trigger ys[i]} | pos <= i < |xs| - 1 :: ys[i] == xs[i + 1]
  {
    xs[..pos] + xs[pos + 1..]
  }

  function {:opaque} RemoveValue<T(==)>(xs: seq<T>, v: T): (ys: seq<T>)
    ensures v !in xs ==> xs == ys
    ensures v in xs ==> |multiset(ys)| == |multiset(xs)| - 1
    ensures v in xs ==> multiset(ys)[v] == multiset(xs)[v] - 1
    ensures HasNoDuplicates(xs) ==> HasNoDuplicates(ys) && ToSet(ys) == ToSet(xs) - {v}
  {
    reveal HasNoDuplicates();
    reveal ToSet();
    if v !in xs then
      xs
    else
      var i := IndexOf(xs, v); assert xs == xs[..i] + [v] + xs[i + 1..]; xs[..i] + xs[i + 1..]
  }

  function {:opaque} Insert<T>(xs: seq<T>, a: T, pos: nat): seq<T>
    requires pos <= |xs|
    ensures |Insert(xs, a, pos)| == |xs| + 1
    ensures forall i {:trigger Insert(xs, a, pos)[i], xs[i]} :: 0 <= i < pos ==> Insert(xs, a, pos)[i] == xs[i]
    ensures forall i {:trigger xs[i]} :: pos <= i < |xs| ==> Insert(xs, a, pos)[i + 1] == xs[i]
    ensures Insert(xs, a, pos)[pos] == a
    ensures multiset(Insert(xs, a, pos)) == multiset(xs) + multiset{a}
  {
    assert xs == xs[..pos] + xs[pos..];
    xs[..pos] + [a] + xs[pos..]
  }

  function {:opaque} Reverse<T>(xs: seq<T>): (ys: seq<T>)
    ensures |ys| == |xs|
    ensures forall i {:trigger ys[i]} {:trigger xs[|xs| - i - 1]} :: 0 <= i < |xs| ==> ys[i] == xs[|xs| - i - 1]
  {
    if xs == [] then
      []
    else
      [xs[|xs| - 1]] + Reverse(xs[0 .. |xs| - 1])
  }

  function {:opaque} Repeat<T>(v: T, length: nat): (xs: seq<T>)
    ensures |xs| == length
    ensures forall i: nat {:trigger xs[i]} | i < |xs| :: xs[i] == v
  {
    if length == 0 then
      []
    else
      [v] + Repeat(v, length - 1)
  }

  function {:opaque} Unzip<A, B>(xs: seq<(A, B)>): (seq<A>, seq<B>)
    ensures |Unzip(xs).0| == |Unzip(xs).1| == |xs|
    ensures forall i {:trigger Unzip(xs).0[i]} {:trigger Unzip(xs).1[i]} :: 0 <= i < |xs| ==> (Unzip(xs).0[i], Unzip(xs).1[i]) == xs[i]
  {
    if |xs| == 0 then
      ([], [])
    else
      var (a, b) := Unzip(DropLast(xs)); (a + [Last(xs).0], b + [Last(xs).1])
  }

  function {:opaque} Zip<A, B>(xs: seq<A>, ys: seq<B>): seq<(A, B)>
    requires |xs| == |ys|
    ensures |Zip(xs, ys)| == |xs|
    ensures forall i {:trigger Zip(xs, ys)[i]} :: 0 <= i < |Zip(xs, ys)| ==> Zip(xs, ys)[i] == (xs[i], ys[i])
    ensures Unzip(Zip(xs, ys)).0 == xs
    ensures Unzip(Zip(xs, ys)).1 == ys
  {
    if |xs| == 0 then
      []
    else
      Zip(DropLast(xs), DropLast(ys)) + [(Last(xs), Last(ys))]
  }

  lemma LemmaZipOfUnzip<A, B>(xs: seq<(A, B)>)
    ensures Zip(Unzip(xs).0, Unzip(xs).1) == xs
  {
  }

  function {:opaque} Max(xs: seq<int>): int
    requires 0 < |xs|
    ensures forall k {:trigger k in xs} :: k in xs ==> Max(xs) >= k
    ensures Max(xs) in xs
  {
    assert xs == [xs[0]] + xs[1..];
    if |xs| == 1 then
      xs[0]
    else
      Math.Max(xs[0], Max(xs[1..]))
  }

  lemma LemmaMaxOfConcat(xs: seq<int>, ys: seq<int>)
    requires 0 < |xs| && 0 < |ys|
    ensures Max(xs + ys) >= Max(xs)
    ensures Max(xs + ys) >= Max(ys)
    ensures forall i {:trigger i in [Max(xs + ys)]} :: i in xs + ys ==> Max(xs + ys) >= i
  {
    reveal Max();
    if |xs| == 1 {
    } else {
      assert xs[1..] + ys == (xs + ys)[1..];
      LemmaMaxOfConcat(xs[1..], ys);
    }
  }

  function {:opaque} Min(xs: seq<int>): int
    requires 0 < |xs|
    ensures forall k {:trigger k in xs} :: k in xs ==> Min(xs) <= k
    ensures Min(xs) in xs
  {
    assert xs == [xs[0]] + xs[1..];
    if |xs| == 1 then
      xs[0]
    else
      Math.Min(xs[0], Min(xs[1..]))
  }

  lemma LemmaMinOfConcat(xs: seq<int>, ys: seq<int>)
    requires 0 < |xs| && 0 < |ys|
    ensures Min(xs + ys) <= Min(xs)
    ensures Min(xs + ys) <= Min(ys)
    ensures forall i {:trigger i in xs + ys} :: i in xs + ys ==> Min(xs + ys) <= i
  {
    reveal Min();
    if |xs| == 1 {
    } else {
      assert xs[1..] + ys == (xs + ys)[1..];
      LemmaMinOfConcat(xs[1..], ys);
    }
  }

  lemma LemmaSubseqMax(xs: seq<int>, from: nat, to: nat)
    requires from < to <= |xs|
    ensures Max(xs[from .. to]) <= Max(xs)
  {
    var subseq := xs[from .. to];
    var subseqMax := Max(subseq);
    assert forall x | x in subseq :: x in xs[from..];
    assert subseqMax in subseq;
    assert subseqMax in xs;
  }

  lemma LemmaSubseqMin(xs: seq<int>, from: nat, to: nat)
    requires from < to <= |xs|
    ensures Min(xs[from .. to]) >= Min(xs)
  {
    var subseq := xs[from .. to];
    var subseqMin := Min(subseq);
    assert forall x | x in subseq :: x in xs[from..];
    assert subseqMin in subseq;
    assert subseqMin in xs;
  }

  function Flatten<T>(xs: seq<seq<T>>): seq<T>
    decreases |xs|
  {
    if |xs| == 0 then
      []
    else
      xs[0] + Flatten(xs[1..])
  }

  lemma {:vcs_split_on_every_assert} LemmaFlattenConcat<T>(xs: seq<seq<T>>, ys: seq<seq<T>>)
    ensures Flatten(xs + ys) == Flatten(xs) + Flatten(ys)
  {
    if |xs| == 0 {
      assert xs + ys == ys;
    } else {
      calc == {
        Flatten(xs + ys);
        {
          assert (xs + ys)[0] == xs[0];
          assert (xs + ys)[1..] == xs[1..] + ys;
        }
        xs[0] + Flatten(xs[1..] + ys);
        xs[0] + Flatten(xs[1..]) + Flatten(ys);
        Flatten(xs) + Flatten(ys);
      }
    }
  }

  function FlattenReverse<T>(xs: seq<seq<T>>): seq<T>
    decreases |xs|
  {
    if |xs| == 0 then
      []
    else
      FlattenReverse(DropLast(xs)) + Last(xs)
  }

  lemma LemmaFlattenReverseConcat<T>(xs: seq<seq<T>>, ys: seq<seq<T>>)
    ensures FlattenReverse(xs + ys) == FlattenReverse(xs) + FlattenReverse(ys)
  {
    if |ys| == 0 {
      assert FlattenReverse(ys) == [];
      assert xs + ys == xs;
    } else {
      calc == {
        FlattenReverse(xs + ys);
        {
          assert Last(xs + ys) == Last(ys);
          assert DropLast(xs + ys) == xs + DropLast(ys);
        }
        FlattenReverse(xs + DropLast(ys)) + Last(ys);
        FlattenReverse(xs) + FlattenReverse(DropLast(ys)) + Last(ys);
        FlattenReverse(xs) + FlattenReverse(ys);
      }
    }
  }

  lemma LemmaFlattenAndFlattenReverseAreEquivalent<T>(xs: seq<seq<T>>)
    ensures Flatten(xs) == FlattenReverse(xs)
  {
    if |xs| == 0 {
    } else {
      calc == {
        FlattenReverse(xs);
        FlattenReverse(DropLast(xs)) + Last(xs);
        {
          LemmaFlattenAndFlattenReverseAreEquivalent(DropLast(xs));
        }
        Flatten(DropLast(xs)) + Last(xs);
        Flatten(DropLast(xs)) + Flatten([Last(xs)]);
        {
          LemmaFlattenConcat(DropLast(xs), [Last(xs)]);
          assert xs == DropLast(xs) + [Last(xs)];
        }
        Flatten(xs);
      }
    }
  }

  lemma LemmaFlattenLengthGeSingleElementLength<T>(xs: seq<seq<T>>, i: int)
    requires 0 <= i < |xs|
    ensures |FlattenReverse(xs)| >= |xs[i]|
  {
    if i < |xs| - 1 {
      LemmaFlattenLengthGeSingleElementLength(xs[..|xs| - 1], i);
    }
  }

  lemma LemmaFlattenLengthLeMul<T>(xs: seq<seq<T>>, j: int)
    requires forall i {:trigger xs[i]} | 0 <= i < |xs| :: |xs[i]| <= j
    ensures |FlattenReverse(xs)| <= |xs| * j
  {
    if |xs| == 0 {
    } else {
      LemmaFlattenLengthLeMul(xs[..|xs| - 1], j);
      assert |FlattenReverse(xs[..|xs| - 1])| <= (|xs| - 1) * j;
    }
  }

  function {:opaque} Map<T, R>(f: T ~> R, xs: seq<T>): (result: seq<R>)
    requires forall i {:trigger xs[i]} :: 0 <= i < |xs| ==> f.requires(xs[i])
    reads set i, o {:trigger o in f.reads(xs[i])} | 0 <= i < |xs| && o in f.reads(xs[i]) :: o
    ensures |result| == |xs|
    ensures forall i {:trigger result[i]} :: 0 <= i < |xs| ==> result[i] == f(xs[i])
  {
    if |xs| == 0 then
      []
    else
      [f(xs[0])] + Map(f, xs[1..])
  }

  function {:opaque} MapWithResult<T, R, E>(f: T ~> Result<R, E>, xs: seq<T>): (result: Result<seq<R>, E>)
    requires forall i :: 0 <= i < |xs| ==> f.requires(xs[i])
    reads set i, o | 0 <= i < |xs| && o in f.reads(xs[i]) :: o
    ensures result.Success? ==> |result.value| == |xs| && forall i :: 0 <= i < |xs| ==> f(xs[i]).Success? && result.value[i] == f(xs[i]).value
  {
    if |xs| == 0 then
      Success([])
    else
      var head :- f(xs[0]); var tail :- MapWithResult(f, xs[1..]); Success([head] + tail)
  }

  lemma {:opaque} {:rlimit 2000} LemmaMapDistributesOverConcat<T, R>(f: T ~> R, xs: seq<T>, ys: seq<T>)
    requires forall i {:trigger xs[i]} :: 0 <= i < |xs| ==> f.requires(xs[i])
    requires forall j {:trigger ys[j]} :: 0 <= j < |ys| ==> f.requires(ys[j])
    ensures Map(f, xs + ys) == Map(f, xs) + Map(f, ys)
  {
    reveal Map();
    if |xs| == 0 {
      assert xs + ys == ys;
    } else {
      calc {
        Map(f, xs + ys);
        {
          assert (xs + ys)[0] == xs[0];
          assert (xs + ys)[1..] == xs[1..] + ys;
        }
        Map(f, [xs[0]]) + Map(f, xs[1..] + ys);
        Map(f, [xs[0]]) + Map(f, xs[1..]) + Map(f, ys);
        {
          assert [(xs + ys)[0]] + xs[1..] + ys == xs + ys;
        }
        Map(f, xs) + Map(f, ys);
      }
    }
  }

  function {:opaque} Filter<T>(f: T ~> bool, xs: seq<T>): (result: seq<T>)
    requires forall i :: 0 <= i < |xs| ==> f.requires(xs[i])
    reads set i, o | 0 <= i < |xs| && o in f.reads(xs[i]) :: o
    ensures |result| <= |xs|
    ensures forall i: nat {:trigger result[i]} :: i < |result| && f.requires(result[i]) ==> f(result[i])
  {
    if |xs| == 0 then
      []
    else
      (if f(xs[0]) then [xs[0]] else []) + Filter(f, xs[1..])
  }

  lemma {:opaque} {:vcs_split_on_every_assert} LemmaFilterDistributesOverConcat<T(!new)>(f: T ~> bool, xs: seq<T>, ys: seq<T>)
    requires forall i {:trigger xs[i]} :: 0 <= i < |xs| ==> f.requires(xs[i])
    requires forall j {:trigger ys[j]} :: 0 <= j < |ys| ==> f.requires(ys[j])
    ensures Filter(f, xs + ys) == Filter(f, xs) + Filter(f, ys)
  {
    reveal Filter();
    if |xs| == 0 {
      assert xs + ys == ys;
    } else {
      calc {
        Filter(f, xs + ys);
        {
          assert {:split_here} (xs + ys)[0] == xs[0];
          assert (xs + ys)[1..] == xs[1..] + ys;
        }
        Filter(f, [xs[0]]) + Filter(f, xs[1..] + ys);
        Filter(f, [xs[0]]) + (Filter(f, xs[1..]) + Filter(f, ys));
        {
          assert {:split_here} [(xs + ys)[0]] + (xs[1..] + ys) == xs + ys;
        }
        Filter(f, xs) + Filter(f, ys);
      }
    }
  }

  function {:opaque} FoldLeft<A, T>(f: (A, T) -> A, init: A, xs: seq<T>): A
  {
    if |xs| == 0 then
      init
    else
      FoldLeft(f, f(init, xs[0]), xs[1..])
  }

  lemma {:opaque} LemmaFoldLeftDistributesOverConcat<A, T>(f: (A, T) -> A, init: A, xs: seq<T>, ys: seq<T>)
    ensures FoldLeft(f, init, xs + ys) == FoldLeft(f, FoldLeft(f, init, xs), ys)
  {
    reveal FoldLeft();
    if |xs| == 0 {
      assert xs + ys == ys;
    } else {
      assert |xs| >= 1;
      assert ([xs[0]] + xs[1..] + ys)[0] == xs[0];
      calc {
        FoldLeft(f, FoldLeft(f, init, xs), ys);
        FoldLeft(f, FoldLeft(f, f(init, xs[0]), xs[1..]), ys);
        {
          LemmaFoldLeftDistributesOverConcat(f, f(init, xs[0]), xs[1..], ys);
        }
        FoldLeft(f, f(init, xs[0]), xs[1..] + ys);
        {
          assert (xs + ys)[0] == xs[0];
          assert (xs + ys)[1..] == xs[1..] + ys;
        }
        FoldLeft(f, init, xs + ys);
      }
    }
  }

  ghost predicate InvFoldLeft<A(!new), B(!new)>(inv: (B, seq<A>) -> bool, stp: (B, A, B) -> bool)
  {
    forall x: A, xs: seq<A>, b: B, b': B :: 
      inv(b, [x] + xs) &&
      stp(b, x, b') ==>
        inv(b', xs)
  }

  lemma LemmaInvFoldLeft<A, B>(inv: (B, seq<A>) -> bool, stp: (B, A, B) -> bool, f: (B, A) -> B, b: B, xs: seq<A>)
    requires InvFoldLeft(inv, stp)
    requires forall b, a :: stp(b, a, f(b, a))
    requires inv(b, xs)
    ensures inv(FoldLeft(f, b, xs), [])
  {
    reveal FoldLeft();
    if xs == [] {
    } else {
      assert [xs[0]] + xs[1..] == xs;
      LemmaInvFoldLeft(inv, stp, f, f(b, xs[0]), xs[1..]);
    }
  }

  function {:opaque} FoldRight<A, T>(f: (T, A) -> A, xs: seq<T>, init: A): A
  {
    if |xs| == 0 then
      init
    else
      f(xs[0], FoldRight(f, xs[1..], init))
  }

  lemma {:opaque} LemmaFoldRightDistributesOverConcat<A, T>(f: (T, A) -> A, init: A, xs: seq<T>, ys: seq<T>)
    ensures FoldRight(f, xs + ys, init) == FoldRight(f, xs, FoldRight(f, ys, init))
  {
    reveal FoldRight();
    if |xs| == 0 {
      assert xs + ys == ys;
    } else {
      calc {
        FoldRight(f, xs, FoldRight(f, ys, init));
        f(xs[0], FoldRight(f, xs[1..], FoldRight(f, ys, init)));
        f(xs[0], FoldRight(f, xs[1..] + ys, init));
        {
          assert (xs + ys)[0] == xs[0];
          assert (xs + ys)[1..] == xs[1..] + ys;
        }
        FoldRight(f, xs + ys, init);
      }
    }
  }

  ghost predicate InvFoldRight<A(!new), B(!new)>(inv: (seq<A>, B) -> bool, stp: (A, B, B) -> bool)
  {
    forall x: A, xs: seq<A>, b: B, b': B :: 
      inv(xs, b) &&
      stp(x, b, b') ==>
        inv([x] + xs, b')
  }

  lemma LemmaInvFoldRight<A, B>(inv: (seq<A>, B) -> bool, stp: (A, B, B) -> bool, f: (A, B) -> B, b: B, xs: seq<A>)
    requires InvFoldRight(inv, stp)
    requires forall a, b :: stp(a, b, f(a, b))
    requires inv([], b)
    ensures inv(xs, FoldRight(f, xs, b))
  {
    reveal FoldRight();
    if xs == [] {
    } else {
      assert [xs[0]] + xs[1..] == xs;
    }
  }

  ghost function SetToSeqSpec<T>(s: set<T>): (xs: seq<T>)
    ensures multiset(s) == multiset(xs)
  {
    if s == {} then
      []
    else
      var x :| x in s; [x] + SetToSeqSpec(s - {x})
  }

  method SetToSeq<T>(s: set<T>) returns (xs: seq<T>)
    ensures multiset(s) == multiset(xs)
  {
    xs := [];
    var left: set<T> := s;
    while left != {}
      invariant multiset(left) + multiset(xs) == multiset(s)
    {
      var x :| x in left;
      left := left - {x};
      xs := xs + [x];
    }
  }

  lemma SortedUnique<T>(xs: seq<T>, ys: seq<T>, R: (T, T) -> bool)
    requires SortedBy(R, xs)
    requires SortedBy(R, ys)
    requires TotalOrdering(R)
    requires multiset(xs) == multiset(ys)
    ensures xs == ys
  {
    if xs == [] {
      assert multiset(xs) == multiset{};
      assert multiset(ys) == multiset{};
      assert ys == [];
    } else {
      assert xs == [xs[0]] + xs[1..];
      assert ys == [ys[0]] + ys[1..];
      assert multiset(xs[1..]) == multiset(xs) - multiset{xs[0]};
      assert multiset(ys[1..]) == multiset(ys) - multiset{ys[0]};
      assert multiset(xs[1..]) == multiset(ys[1..]);
      SortedUnique(xs[1..], ys[1..], R);
    }
  }

  ghost function SetToSortedSeqSpec<T>(s: set<T>, R: (T, T) -> bool): (xs: seq<T>)
    requires TotalOrdering(R)
    ensures multiset(s) == multiset(xs)
    ensures SortedBy(R, xs)
  {
    MergeSortBy(R, SetToSeqSpec(s))
  }

  method SetToSortedSeq<T>(s: set<T>, R: (T, T) -> bool) returns (xs: seq<T>)
    requires TotalOrdering(R)
    ensures multiset(s) == multiset(xs)
    ensures SortedBy(R, xs)
  {
    xs := SetToSeq(s);
    xs := MergeSortBy(R, xs);
    SortedUnique(xs, SetToSortedSeqSpec(s, R), R);
  }

  function MergeSortBy<T>(lessThanOrEq: (T, T) -> bool, a: seq<T>): (result: seq<T>)
    requires TotalOrdering(lessThanOrEq)
    ensures multiset(a) == multiset(result)
    ensures SortedBy(lessThanOrEq, result)
  {
    if |a| <= 1 then
      a
    else
      var splitIndex := |a| / 2; var left, right := a[..splitIndex], a[splitIndex..]; assert a == left + right; var leftSorted := MergeSortBy(lessThanOrEq, left); var rightSorted := MergeSortBy(lessThanOrEq, right); MergeSortedWith(leftSorted, rightSorted, lessThanOrEq)
  }

  function {:tailrecursion} MergeSortedWith<T>(left: seq<T>, right: seq<T>, lessThanOrEq: (T, T) -> bool): (result: seq<T>)
    requires SortedBy(lessThanOrEq, left)
    requires SortedBy(lessThanOrEq, right)
    requires TotalOrdering(lessThanOrEq)
    ensures multiset(left + right) == multiset(result)
    ensures SortedBy(lessThanOrEq, result)
  {
    if |left| == 0 then
      right
    else if |right| == 0 then
      left
    else if lessThanOrEq(left[0], right[0]) then
      LemmaNewFirstElementStillSortedBy(left[0], MergeSortedWith(left[1..], right, lessThanOrEq), lessThanOrEq);
      assert left == [left[0]] + left[1..];
      [left[0]] + MergeSortedWith(left[1..], right, lessThanOrEq)
    else
      LemmaNewFirstElementStillSortedBy(right[0], MergeSortedWith(left, right[1..], lessThanOrEq), lessThanOrEq); assert right == [right[0]] + right[1..]; [right[0]] + MergeSortedWith(left, right[1..], lessThanOrEq)
  }

  lemma LemmaNewFirstElementStillSortedBy<T>(newFirst: T, s: seq<T>, lessOrEqual: (T, T) -> bool)
    requires SortedBy(lessOrEqual, s)
    requires |s| == 0 || lessOrEqual(newFirst, s[0])
    requires TotalOrdering(lessOrEqual)
    ensures SortedBy(lessOrEqual, [newFirst] + s)
  {
  }

  import opened Wrappers

  import opened Relations

  import Math
}

module DafnyStdLibs.Collections.Sets {
  lemma LemmaSubset<T>(x: set<T>, y: set<T>)
    requires forall e {:trigger e in y} :: e in x ==> e in y
    ensures x <= y
  {
  }

  lemma LemmaSubsetSize<T>(x: set<T>, y: set<T>)
    ensures x < y ==> |x| < |y|
    ensures x <= y ==> |x| <= |y|
  {
    if x != {} {
      var e :| e in x;
      LemmaSubsetSize(x - {e}, y - {e});
    }
  }

  lemma LemmaSubsetEquality<T>(x: set<T>, y: set<T>)
    requires x <= y
    requires |x| == |y|
    ensures x == y
    decreases x, y
  {
    if x == {} {
    } else {
      var e :| e in x;
      LemmaSubsetEquality(x - {e}, y - {e});
    }
  }

  lemma LemmaSingletonSize<T>(x: set<T>, e: T)
    requires x == {e}
    ensures |x| == 1
  {
  }

  lemma LemmaSingletonEquality<T>(x: set<T>, a: T, b: T)
    requires |x| == 1
    requires a in x
    requires b in x
    ensures a == b
  {
    if a != b {
      assert {a} < x;
      LemmaSubsetSize({a}, x);
      assert false;
    }
  }

  ghost predicate IsSingleton<T>(s: set<T>)
  {
    (exists x :: 
      x in s) &&
    forall x, y | x in s && y in s :: 
      x == y
  }

  lemma LemmaIsSingleton<T>(s: set<T>)
    ensures |s| == 1 <==> IsSingleton(s)
  {
    if |s| == 1 {
      forall x, y | x in s && y in s
        ensures x == y
      {
        LemmaSingletonEquality(s, x, y);
      }
    }
    if IsSingleton(s) {
      var x :| x in s;
      assert s == {x};
      assert |s| == 1;
    }
  }

  ghost function ExtractFromNonEmptySet<T>(s: set<T>): (x: T)
    requires |s| != 0
    ensures x in s
  {
    var x :| x in s;
    x
  }

  function ExtractFromSingleton<T>(s: set<T>): (x: T)
    requires |s| == 1
    ensures s == {x}
  {
    LemmaIsSingleton(s);
    var x :| x in s;
    x
  }

  lemma LemmaMapSize<X(!new), Y>(xs: set<X>, ys: set<Y>, f: X --> Y)
    requires forall x {:trigger f.requires(x)} :: f.requires(x)
    requires Injective(f)
    requires forall x {:trigger f(x)} :: x in xs <==> f(x) in ys
    requires forall y {:trigger y in ys} :: y in ys ==> exists x :: x in xs && y == f(x)
    ensures |xs| == |ys|
  {
    if xs != {} {
      var x :| x in xs;
      var xs' := xs - {x};
      var ys' := ys - {f(x)};
      LemmaMapSize(xs', ys', f);
    }
  }

  function {:opaque} Map<X(!new), Y>(f: X --> Y, xs: set<X>): (ys: set<Y>)
    requires forall x {:trigger f.requires(x)} :: f.requires(x)
    requires Injective(f)
    reads f.reads
    ensures forall x {:trigger f(x)} :: x in xs <==> f(x) in ys
    ensures |xs| == |ys|
  {
    var ys := set x | x in xs :: f(x);
    LemmaMapSize(xs, ys, f);
    ys
  }

  lemma LemmaFilterSize<X>(xs: set<X>, ys: set<X>, f: X ~> bool)
    requires forall x {:trigger f.requires(x)} {:trigger x in xs} :: x in xs ==> f.requires(x)
    requires forall y {:trigger f(y)} {:trigger y in xs} :: y in ys ==> y in xs && f(y)
    ensures |ys| <= |xs|
    decreases xs, ys
  {
    if ys != {} {
      var y :| y in ys;
      var xs' := xs - {y};
      var ys' := ys - {y};
      LemmaFilterSize(xs', ys', f);
    }
  }

  function {:opaque} Filter<X(!new)>(f: X ~> bool, xs: set<X>): (ys: set<X>)
    requires forall x {:trigger f.requires(x)} {:trigger x in xs} :: x in xs ==> f.requires(x)
    reads set x, o | x in xs && o in f.reads(x) :: o
    ensures forall y {:trigger f(y)} {:trigger y in xs} :: y in ys <==> y in xs && f(y)
    ensures |ys| <= |xs|
  {
    var ys := set x | x in xs && f(x);
    LemmaFilterSize(xs, ys, f);
    ys
  }

  lemma LemmaUnionSize<X>(xs: set<X>, ys: set<X>)
    ensures |xs + ys| >= |xs|
    ensures |xs + ys| >= |ys|
  {
    if ys == {} {
    } else {
      var y :| y in ys;
      if y in xs {
        var xr := xs - {y};
        var yr := ys - {y};
        assert xr + yr == xs + ys - {y};
        LemmaUnionSize(xr, yr);
      } else {
        var yr := ys - {y};
        assert xs + yr == xs + ys - {y};
        LemmaUnionSize(xs, yr);
      }
    }
  }

  function {:opaque} SetRange(a: int, b: int): (s: set<int>)
    requires a <= b
    ensures forall i {:trigger i in s} :: a <= i < b <==> i in s
    ensures |s| == b - a
    decreases b - a
  {
    if a == b then
      {}
    else
      {a} + SetRange(a + 1, b)
  }

  function {:opaque} SetRangeZeroBound(n: int): (s: set<int>)
    requires n >= 0
    ensures forall i {:trigger i in s} :: 0 <= i < n <==> i in s
    ensures |s| == n
  {
    SetRange(0, n)
  }

  lemma LemmaBoundedSetSize(x: set<int>, a: int, b: int)
    requires forall i {:trigger i in x} :: i in x ==> a <= i < b
    requires a <= b
    ensures |x| <= b - a
  {
    var range := SetRange(a, b);
    forall e {:trigger e in range} {:trigger e in x} | e in x
      ensures e in range
    {
    }
    assert x <= range;
    LemmaSubsetSize(x, range);
  }

  lemma LemmaGreatestImpliesMaximal<T(!new)>(R: (T, T) -> bool, max: T, s: set<T>)
    requires IsGreatest(R, max, s)
    ensures IsMaximal(R, max, s)
  {
  }

  lemma LemmaLeastImpliesMinimal<T(!new)>(R: (T, T) -> bool, min: T, s: set<T>)
    requires IsLeast(R, min, s)
    ensures IsMinimal(R, min, s)
  {
  }

  lemma LemmaMaximalEquivalentGreatest<T(!new)>(R: (T, T) -> bool, max: T, s: set<T>)
    requires TotalOrdering(R)
    ensures IsGreatest(R, max, s) <==> IsMaximal(R, max, s)
  {
  }

  lemma LemmaMinimalEquivalentLeast<T(!new)>(R: (T, T) -> bool, min: T, s: set<T>)
    requires TotalOrdering(R)
    ensures IsLeast(R, min, s) <==> IsMinimal(R, min, s)
  {
  }

  lemma LemmaLeastIsUnique<T(!new)>(R: (T, T) -> bool, s: set<T>)
    requires PartialOrdering(R)
    ensures forall min, min' | IsLeast(R, min, s) && IsLeast(R, min', s) :: min == min'
  {
  }

  lemma LemmaGreatestIsUnique<T(!new)>(R: (T, T) -> bool, s: set<T>)
    requires PartialOrdering(R)
    ensures forall max, max' | IsGreatest(R, max, s) && IsGreatest(R, max', s) :: max == max'
  {
  }

  lemma LemmaMinimalIsUnique<T(!new)>(R: (T, T) -> bool, s: set<T>)
    requires TotalOrdering(R)
    ensures forall min, min' | IsMinimal(R, min, s) && IsMinimal(R, min', s) :: min == min'
  {
  }

  lemma LemmaMaximalIsUnique<T(!new)>(R: (T, T) -> bool, s: set<T>)
    requires TotalOrdering(R)
    ensures forall max, max' | IsMaximal(R, max, s) && IsMaximal(R, max', s) :: max == max'
  {
  }

  lemma LemmaFindUniqueMinimal<T(!new)>(R: (T, T) -> bool, s: set<T>) returns (min: T)
    requires |s| > 0 && TotalOrdering(R)
    ensures IsMinimal(R, min, s) && forall min': T | IsMinimal(R, min', s) :: min == min'
  {
    var x :| x in s;
    if s == {x} {
      min := x;
    } else {
      var min' := LemmaFindUniqueMinimal(R, s - {x});
      if
      case R(min', x) =>
        min := min';
      case R(x, min') =>
        min := x;
    }
  }

  lemma LemmaFindUniqueMaximal<T(!new)>(R: (T, T) -> bool, s: set<T>) returns (max: T)
    requires |s| > 0 && TotalOrdering(R)
    ensures IsMaximal(R, max, s) && forall max': T | IsMaximal(R, max', s) :: max == max'
  {
    var x :| x in s;
    if s == {x} {
      max := x;
    } else {
      var max' := LemmaFindUniqueMaximal(R, s - {x});
      if
      case R(max', x) =>
        max := x;
      case R(x, max') =>
        max := max';
    }
  }

  import opened Functions

  import opened Relations
}

module DafnyStdLibs.DynamicArray {

  import opened BoundedInts

  import opened Wrappers

  export
    reveals DynamicArray
    provides BoundedInts, DynamicArray.items, DynamicArray.capacity, DynamicArray.Repr, DynamicArray.Valid?, DynamicArray.size, DynamicArray.At, DynamicArray.Put, DynamicArray.Push, DynamicArray.PushFast, DynamicArray.PopFast, DynamicArray.Ensure

  class DynamicArray<A> {
    ghost var items: seq<A>
    ghost var Repr: set<object>
    var size: nat
    var capacity: nat
    var data: array<A>

    ghost predicate Valid?()
      reads this, Repr
    {
      Repr == {this, data} &&
      data.Length == capacity as int &&
      size <= capacity &&
      size as int == |items| &&
      items == data[..size]
    }

    constructor ()
      ensures size == 0
      ensures items == []
      ensures fresh(Repr)
      ensures capacity == 0
      ensures Valid?()
    {
      items := [];
      size := 0;
      capacity := 0;
      data := new A[0];
      Repr := {this, data};
    }

    function At(index: nat): (element: A)
      requires index < size
      requires Valid?()
      reads this, Repr
      ensures element == items[index]
    {
      data[index]
    }

    method Put(index: nat, element: A)
      requires index < size
      requires Valid?()
      modifies Repr, `items
      ensures Valid?()
      ensures fresh(Repr - old(Repr))
      ensures size == old(size)
      ensures items == old(items)[index := element]
    {
      data[index] := element;
      items := items[index := element];
    }

    method Ensure(reserved: nat, defaultValue: A)
      requires Valid?()
      modifies `capacity, Repr
      ensures Valid?()
      ensures size == old(size)
      ensures items == old(items)
      ensures fresh(Repr - old(Repr))
      ensures reserved <= capacity - size
    {
      var newCapacity := capacity;
      while reserved > newCapacity - size
        invariant newCapacity >= capacity
      {
        newCapacity := DefaultNewCapacity(newCapacity);
      }
      if newCapacity > capacity {
        Realloc(defaultValue, newCapacity);
      }
    }

    method PopFast()
      requires Valid?()
      requires size > 0
      modifies `size, `items
      ensures Valid?()
      ensures size < capacity
      ensures size == old(size) - 1
      ensures capacity == old(capacity)
      ensures items == old(items[..|items| - 1])
    {
      size := size - 1;
      items := items[..|items| - 1];
    }

    method PushFast(element: A)
      requires Valid?()
      requires size < capacity
      modifies Repr, `size, `items
      ensures Valid?()
      ensures fresh(Repr - old(Repr))
      ensures size == old(size) + 1
      ensures capacity == old(capacity)
      ensures items == old(items) + [element]
    {
      data[size] := element;
      size := size + 1;
      items := items + [element];
    }

    method Push(element: A)
      requires Valid?()
      modifies Repr
      ensures Valid?()
      ensures fresh(Repr - old(Repr))
      ensures size == old(size) + 1
      ensures items == old(items) + [element]
      ensures capacity >= old(capacity)
    {
      if size == capacity {
        ReallocDefault(element);
      }
      PushFast(element);
    }

    method Realloc(defaultValue: A, newCapacity: nat)
      requires Valid?()
      requires newCapacity > capacity
      modifies `capacity, `data, `Repr, data
      ensures Valid?()
      ensures capacity == newCapacity
      ensures fresh(data)
    {
      var oldData, oldCapacity := data, capacity;
      data, capacity := new A[newCapacity] (_ /* _v0 */ => defaultValue), newCapacity;
      CopyFrom(oldData, oldCapacity);
      Repr := {this, data};
    }

    function DefaultNewCapacity(capacity: nat): nat
    {
      if capacity == 0 then
        8
      else
        2 * capacity
    }

    method ReallocDefault(defaultValue: A)
      requires Valid?()
      modifies `capacity, `data, `Repr, data
      ensures Valid?()
      ensures fresh(data)
      ensures capacity == old(DefaultNewCapacity(capacity))
    {
      Realloc(defaultValue, DefaultNewCapacity(capacity));
    }

    method CopyFrom(newData: array<A>, count: nat)
      requires count as int <= newData.Length
      requires count <= capacity
      requires data.Length == capacity as int
      modifies data
      ensures data[..count] == newData[..count]
      ensures data[count..] == old(data[count..])
    {
      forall index | 0 <= index < count {
        data[index] := newData[index];
      }
    }
  }
}

module DafnyStdLibs.Functions {
  ghost predicate Injective<X(!new), Y>(f: X --> Y)
    requires forall x :: f.requires(x)
    reads f.reads
  {
    forall x1, x2 :: 
      f(x1) == f(x2) ==>
        x1 == x2
  }

  ghost predicate Commutative<T(!new), U(!new)>(f: (T, T) -> U)
    requires forall x, y :: f.requires(x, y) && f.requires(y, x)
    reads f.reads
  {
    forall x, y :: 
      f(x, y) == f(y, x)
  }

  ghost predicate Associative<T(!new)>(f: (T, T) -> T)
    requires forall x, y, z :: f.requires(x, y) && f.requires(y, z) && f.requires(x, z)
    reads f.reads
  {
    forall x, y, z: T :: 
      f(x, f(y, z)) == f(f(x, y), z)
  }
}

module DafnyStdLibs.Math {
  function Min(a: int, b: int): int
  {
    if a < b then
      a
    else
      b
  }

  function Min3(a: int, b: int, c: int): int
  {
    Min(a, Min(b, c))
  }

  function Max(a: int, b: int): int
  {
    if a < b then
      b
    else
      a
  }

  function Max3(a: int, b: int, c: int): int
  {
    Max(a, Max(b, c))
  }

  function Abs(a: int): int
  {
    if a < 0 then
      -a
    else
      a
  }
}

module DafnyStdLibs.Relations {
  ghost predicate Reflexive<T(!new)>(relation: (T, T) -> bool)
  {
    forall x :: 
      relation(x, x)
  }

  ghost predicate Irreflexive<T(!new)>(relation: (T, T) -> bool)
  {
    forall x :: 
      !relation(x, x)
  }

  ghost predicate Symmetric<T(!new)>(relation: (T, T) -> bool)
  {
    forall x, y :: 
      relation(x, y) <==> relation(y, x)
  }

  ghost predicate AntiSymmetric<T(!new)>(relation: (T, T) -> bool)
  {
    forall x, y :: 
      relation(x, y) &&
      relation(y, x) ==>
        x == y
  }

  ghost predicate Asymmetric<T(!new)>(relation: (T, T) -> bool)
  {
    forall x, y :: 
      relation(x, y) ==>
        !relation(y, x)
  }

  lemma AsymmetricIsAntiSymmetric<T>(relation: (T, T) -> bool)
    ensures Asymmetric(relation) ==> AntiSymmetric(relation)
  {
  }

  lemma AsymmetricIsIrreflexive<T>(relation: (T, T) -> bool)
    ensures Asymmetric(relation) ==> Irreflexive(relation)
  {
  }

  ghost predicate Connected<T(!new)>(relation: (T, T) -> bool)
  {
    forall x, y :: 
      x != y ==>
        relation(x, y) || relation(y, x)
  }

  ghost predicate StronglyConnected<T(!new)>(relation: (T, T) -> bool)
  {
    forall x, y :: 
      relation(x, y) || relation(y, x)
  }

  ghost predicate Transitive<T(!new)>(relation: (T, T) -> bool)
  {
    forall x, y, z :: 
      relation(x, y) &&
      relation(y, z) ==>
        relation(x, z)
  }

  ghost predicate TotalOrdering<T(!new)>(relation: (T, T) -> bool)
  {
    Reflexive(relation) &&
    AntiSymmetric(relation) &&
    Transitive(relation) &&
    StronglyConnected(relation)
  }

  ghost predicate StrictTotalOrdering<T(!new)>(relation: (T, T) -> bool)
  {
    Irreflexive(relation) &&
    AntiSymmetric(relation) &&
    Transitive(relation) &&
    Connected(relation)
  }

  ghost predicate PreOrdering<T(!new)>(relation: (T, T) -> bool)
  {
    Reflexive(relation) &&
    Transitive(relation)
  }

  ghost predicate PartialOrdering<T(!new)>(relation: (T, T) -> bool)
  {
    Reflexive(relation) &&
    Transitive(relation) &&
    AntiSymmetric(relation)
  }

  ghost predicate EquivalenceRelation<T(!new)>(relation: (T, T) -> bool)
  {
    Reflexive(relation) &&
    Symmetric(relation) &&
    Transitive(relation)
  }

  ghost predicate IsLeast<T>(lessOrEqual: (T, T) -> bool, least: T, s: set<T>)
  {
    least in s &&
    forall x | x in s :: 
      lessOrEqual(least, x)
  }

  ghost predicate IsMinimal<T>(lessOrEqual: (T, T) -> bool, minimal: T, s: set<T>)
  {
    minimal in s &&
    forall x | x in s && lessOrEqual(x, minimal) :: 
      lessOrEqual(minimal, x)
  }

  ghost predicate IsGreatest<T>(lessOrEqual: (T, T) -> bool, greatest: T, s: set<T>)
  {
    greatest in s &&
    forall x | x in s :: 
      lessOrEqual(x, greatest)
  }

  ghost predicate IsMaximal<T>(lessOrEqual: (T, T) -> bool, maximal: T, s: set<T>)
  {
    maximal in s &&
    forall x | x in s && lessOrEqual(maximal, x) :: 
      lessOrEqual(x, maximal)
  }

  ghost predicate SortedBy<T>(lessOrEqual: (T, T) -> bool, xs: seq<T>)
  {
    forall i, j | 0 <= i < j < |xs| :: 
      lessOrEqual(xs[i], xs[j])
  }
}

module DafnyStdLibs.Unicode {
}

module DafnyStdLibs.Unicode.Base {
  const HIGH_SURROGATE_MIN: CodePoint := 55296
  const HIGH_SURROGATE_MAX: CodePoint := 56319
  const LOW_SURROGATE_MIN: CodePoint := 56320
  const LOW_SURROGATE_MAX: CodePoint := 57343
  const ASSIGNED_PLANES: set<bv8> := {0, 1, 2, 3, 14, 15, 16}

  opaque predicate IsInAssignedPlane(i: CodePoint)
  {
    var plane := (i >> 16) as bv8;
    plane in ASSIGNED_PLANES
  }

  type CodePoint = i: bv24
    | 0 <= i <= 1114111

  type HighSurrogateCodePoint = p: CodePoint
    | HIGH_SURROGATE_MIN <= p <= HIGH_SURROGATE_MAX
    witness HIGH_SURROGATE_MIN

  type LowSurrogateCodePoint = p: CodePoint
    | LOW_SURROGATE_MIN <= p <= LOW_SURROGATE_MAX
    witness LOW_SURROGATE_MIN

  type ScalarValue = p: CodePoint
    | (p < HIGH_SURROGATE_MIN || p > HIGH_SURROGATE_MAX) && (p < LOW_SURROGATE_MIN || p > LOW_SURROGATE_MAX)

  type AssignedCodePoint = p: CodePoint
    | IsInAssignedPlane(p)
    witness *
}

abstract module DafnyStdLibs.Unicode.UnicodeEncodingForm {
  function IsMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq): (b: bool)
    ensures b ==> |s| > 0 && forall i | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i])
    decreases |s|

  function SplitPrefixMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq): (maybePrefix: Option<MinimalWellFormedCodeUnitSeq>)
    ensures |s| == 0 ==> maybePrefix.None?
    ensures (exists i | 0 < i <= |s| :: IsMinimalWellFormedCodeUnitSubsequence(s[..i])) <==> true && maybePrefix.Some?
    ensures maybePrefix.Some? ==> true && var prefix := maybePrefix.Extract(); 0 < |prefix| <= |s| && prefix == s[..|prefix|] && forall i | 0 < i < |prefix| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i])

  function EncodeScalarValue(v: ScalarValue): (m: MinimalWellFormedCodeUnitSeq)

  function DecodeMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq): (v: ScalarValue)
    ensures EncodeScalarValue(v) == m

  lemma LemmaUniquePrefixMinimalWellFormedCodeUnitSeq(s: CodeUnitSeq, m1: MinimalWellFormedCodeUnitSeq, m2: MinimalWellFormedCodeUnitSeq)
    requires m1 <= s
    requires m2 <= s
    ensures m1 == m2
    decreases |s|, |m1|, |m2|
  {
    if |m1| > |m2| {
      LemmaUniquePrefixMinimalWellFormedCodeUnitSeq(s, m2, m1);
    } else {
      assert m1 <= m2;
      assert m1 == m2 by {
        if m1 < m2 {
          assert false by {
            assert m1 == m2[..|m1|];
          }
        }
      }
    }
  }

  lemma LemmaSplitPrefixMinimalWellFormedCodeUnitSubsequenceInvertsPrepend(m: MinimalWellFormedCodeUnitSeq, s: CodeUnitSeq)
    ensures SplitPrefixMinimalWellFormedCodeUnitSubsequence(m + s) == Some(m)
  {
    var ms := m + s;
    var maybePrefix := SplitPrefixMinimalWellFormedCodeUnitSubsequence(ms);
    assert maybePrefix.Some? by {
      assert IsMinimalWellFormedCodeUnitSubsequence(ms[..|m|]);
    }
    var prefix := maybePrefix.Extract();
    assert m <= ms;
    assert prefix <= ms;
    LemmaUniquePrefixMinimalWellFormedCodeUnitSeq(ms, m, prefix);
  }

  function PartitionCodeUnitSequenceChecked(s: CodeUnitSeq): (maybeParts: Option<seq<MinimalWellFormedCodeUnitSeq>>)
    ensures maybeParts.Some? ==> Seqs.Flatten(maybeParts.Extract()) == s
    decreases |s|
  {
    if s == [] then
      Some([])
    else
      var prefix :- SplitPrefixMinimalWellFormedCodeUnitSubsequence(s); var restParts :- PartitionCodeUnitSequenceChecked(s[|prefix|..]); Some([prefix] + restParts)
  } by method {
    if s == [] {
      return Some([]);
    }
    var result: seq<MinimalWellFormedCodeUnitSeq> := [];
    var rest := s;
    while |rest| > 0
      invariant PartitionCodeUnitSequenceChecked(s).Some? <==> PartitionCodeUnitSequenceChecked(rest).Some?
      invariant PartitionCodeUnitSequenceChecked(s).Some? ==> true && PartitionCodeUnitSequenceChecked(s).value == result + PartitionCodeUnitSequenceChecked(rest).value
    {
      var prefix :- SplitPrefixMinimalWellFormedCodeUnitSubsequence(rest);
      result := result + [prefix];
      rest := rest[|prefix|..];
    }
    assert result + [] == result;
    return Some(result);
  }

  function PartitionCodeUnitSequence(s: WellFormedCodeUnitSeq): (parts: seq<MinimalWellFormedCodeUnitSeq>)
    ensures Seqs.Flatten(parts) == s
  {
    PartitionCodeUnitSequenceChecked(s).Extract()
  }

  lemma LemmaPartitionMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq)
    ensures PartitionCodeUnitSequenceChecked(m) == Some([m])
  {
    LemmaSplitPrefixMinimalWellFormedCodeUnitSubsequenceInvertsPrepend(m, []);
    calc == {
      Some(m);
      SplitPrefixMinimalWellFormedCodeUnitSubsequence(m + []);
      {
        assert m + [] == m;
      }
      SplitPrefixMinimalWellFormedCodeUnitSubsequence(m);
    }
    calc == {
      PartitionCodeUnitSequenceChecked(m);
      Some([m] + []);
      {
        assert [m] + [] == [m];
      }
      Some([m]);
    }
  }

  function IsWellFormedCodeUnitSequence(s: CodeUnitSeq): (b: bool)
  {
    PartitionCodeUnitSequenceChecked(s).Some?
  }

  lemma LemmaMinimalWellFormedCodeUnitSubsequenceIsWellFormedSequence(m: MinimalWellFormedCodeUnitSeq)
    ensures IsWellFormedCodeUnitSequence(m)
  {
    LemmaPartitionMinimalWellFormedCodeUnitSubsequence(m);
  }

  lemma LemmaPrependMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq, s: WellFormedCodeUnitSeq)
    ensures IsWellFormedCodeUnitSequence(m + s)
  {
    LemmaPartitionMinimalWellFormedCodeUnitSubsequence(m);
    LemmaSplitPrefixMinimalWellFormedCodeUnitSubsequenceInvertsPrepend(m, s);
  }

  lemma LemmaFlattenMinimalWellFormedCodeUnitSubsequences(ms: seq<MinimalWellFormedCodeUnitSeq>)
    ensures IsWellFormedCodeUnitSequence(Seqs.Flatten(ms))
  {
    if |ms| == 0 {
    } else {
      var head := ms[0];
      var tail := ms[1..];
      LemmaFlattenMinimalWellFormedCodeUnitSubsequences(tail);
      var flatTail := Seqs.Flatten(tail);
      LemmaPrependMinimalWellFormedCodeUnitSubsequence(head, flatTail);
    }
  }

  lemma LemmaConcatWellFormedCodeUnitSubsequences(s: WellFormedCodeUnitSeq, t: WellFormedCodeUnitSeq)
    ensures IsWellFormedCodeUnitSequence(s + t)
  {
    var partsS := PartitionCodeUnitSequence(s);
    var partsT := PartitionCodeUnitSequence(t);
    var partsST := partsS + partsT;
    Seqs.LemmaFlattenConcat(partsS, partsT);
    LemmaFlattenMinimalWellFormedCodeUnitSubsequences(partsST);
  }

  function EncodeScalarSequence(vs: seq<ScalarValue>): (s: WellFormedCodeUnitSeq)
  {
    var ms := Seqs.Map(EncodeScalarValue, vs);
    LemmaFlattenMinimalWellFormedCodeUnitSubsequences(ms);
    Seqs.Flatten(ms)
  } by method {
    s := [];
    ghost var unflattened: seq<MinimalWellFormedCodeUnitSeq> := [];
    for i := |vs| downto 0
      invariant unflattened == Seqs.Map(EncodeScalarValue, vs[i..])
      invariant s == Seqs.Flatten(unflattened)
    {
      var next: MinimalWellFormedCodeUnitSeq := EncodeScalarValue(vs[i]);
      unflattened := [next] + unflattened;
      LemmaPrependMinimalWellFormedCodeUnitSubsequence(next, s);
      s := next + s;
    }
  }

  function DecodeCodeUnitSequence(s: WellFormedCodeUnitSeq): (vs: seq<ScalarValue>)
    ensures EncodeScalarSequence(vs) == s
  {
    var parts := PartitionCodeUnitSequence(s);
    var vs := Seqs.Map(DecodeMinimalWellFormedCodeUnitSubsequence, parts);
    calc == {
      s;
      Seqs.Flatten(parts);
      {
        assert parts == Seqs.Map(EncodeScalarValue, vs);
      }
      Seqs.Flatten(Seqs.Map(EncodeScalarValue, vs));
      EncodeScalarSequence(vs);
    }
    vs
  }

  function DecodeCodeUnitSequenceChecked(s: CodeUnitSeq): (maybeVs: Option<seq<ScalarValue>>)
    ensures IsWellFormedCodeUnitSequence(s) ==> maybeVs.Some? && maybeVs.Extract() == DecodeCodeUnitSequence(s)
    ensures !IsWellFormedCodeUnitSequence(s) ==> true && maybeVs.None?
  {
    if IsWellFormedCodeUnitSequence(s) then
      Some(DecodeCodeUnitSequence(s))
    else
      None
  } by method {
    var maybeParts := PartitionCodeUnitSequenceChecked(s);
    if maybeParts.None? {
      return None;
    }
    var parts := maybeParts.value;
    var vs := Seqs.Map(DecodeMinimalWellFormedCodeUnitSubsequence, parts);
    calc == {
      s;
      Seqs.Flatten(parts);
      {
        assert parts == Seqs.Map(EncodeScalarValue, vs);
      }
      Seqs.Flatten(Seqs.Map(EncodeScalarValue, vs));
      EncodeScalarSequence(vs);
    }
    return Some(vs);
  }

  import opened Wrappers

  import Functions

  import Seqs = Collections.Seqs

  import opened Base

  type CodeUnitSeq = seq<CodeUnit>

  type WellFormedCodeUnitSeq = s: CodeUnitSeq
    | IsWellFormedCodeUnitSequence(s)
    witness []

  type MinimalWellFormedCodeUnitSeq = s: CodeUnitSeq
    | IsMinimalWellFormedCodeUnitSubsequence(s)
    witness *

  type CodeUnit
}

abstract module DafnyStdLibs.Unicode.AbstractUnicodeStrings {
  function ToUTF8Checked(s: string): Option<seq<uint8>>

  function ASCIIToUTF8(s: string): seq<uint8>
    requires forall i | 0 <= i < |s| :: 0 <= s[i] as int < 128
  {
    Seqs.Map(c requires 0 <= c as int < 128 => c as uint8, s)
  }

  function FromUTF8Checked(bs: seq<uint8>): Option<string>

  function ToUTF16Checked(s: string): Option<seq<uint16>>

  function ASCIIToUTF16(s: string): seq<uint16>
    requires forall i | 0 <= i < |s| :: 0 <= s[i] as int < 128
  {
    Seqs.Map(c requires 0 <= c as int < 128 => c as uint16, s)
  }

  function FromUTF16Checked(bs: seq<uint16>): Option<string>

  import Seqs = Collections.Seqs

  import opened Wrappers

  import opened BoundedInts
}

module DafnyStdLibs.Unicode.UnicodeStringsWithUnicodeChar refines AbstractUnicodeStrings {
  lemma {:vcs_split_on_every_assert} CharIsUnicodeScalarValue(c: char)
    ensures true && var asBits := c as bv24; asBits <= 1114111 && (0 <= asBits < Base.HIGH_SURROGATE_MIN || Base.LOW_SURROGATE_MAX < asBits)
  {
    assert c as int < 1114112;
    assume {:axiom} c as bv24 < 1114112 as bv24;
    var asBits := c as int as bv24;
    assert asBits < Base.HIGH_SURROGATE_MIN || asBits > Base.LOW_SURROGATE_MAX;
    assert asBits <= 1114111;
  }

  lemma UnicodeScalarValueIsChar(sv: Base.ScalarValue)
    ensures true && var asInt := sv as int; true && (0 <= asInt < 55296 || 57344 <= asInt < 1114112)
  {
    var asInt := sv as int;
    assert asInt < 55296 || asInt > 57343;
    assert asInt < 56319 || asInt > 56320;
  }

  function CharAsUnicodeScalarValue(c: char): Base.ScalarValue
  {
    CharIsUnicodeScalarValue(c);
    c as Base.ScalarValue
  }

  function CharFromUnicodeScalarValue(sv: Base.ScalarValue): char
  {
    UnicodeScalarValueIsChar(sv);
    sv as int as char
  }

  function ToUTF8Checked(s: string): Option<seq<uint8>>
    ensures ToUTF8Checked(s).Some?
  {
    var asCodeUnits := Seqs.Map(CharAsUnicodeScalarValue, s);
    var asUtf8CodeUnits := Utf8EncodingForm.EncodeScalarSequence(asCodeUnits);
    var asBytes := Seqs.Map(cu => cu as uint8, asUtf8CodeUnits);
    Some(asBytes)
  }

  function FromUTF8Checked(bs: seq<uint8>): Option<string>
  {
    var asCodeUnits := Seqs.Map(c => c as Utf8EncodingForm.CodeUnit, bs);
    var utf32 :- Utf8EncodingForm.DecodeCodeUnitSequenceChecked(asCodeUnits); var asChars := Seqs.Map(CharFromUnicodeScalarValue, utf32); Some(asChars)
  }

  function ToUTF16Checked(s: string): Option<seq<uint16>>
    ensures ToUTF16Checked(s).Some?
  {
    var asCodeUnits := Seqs.Map(CharAsUnicodeScalarValue, s);
    var asUtf16CodeUnits := Utf16EncodingForm.EncodeScalarSequence(asCodeUnits);
    var asBytes := Seqs.Map(cu => cu as uint16, asUtf16CodeUnits);
    Some(asBytes)
  }

  function FromUTF16Checked(bs: seq<uint16>): Option<string>
  {
    var asCodeUnits := Seqs.Map(c => c as Utf16EncodingForm.CodeUnit, bs);
    var utf32 :- Utf16EncodingForm.DecodeCodeUnitSequenceChecked(asCodeUnits); var asChars := Seqs.Map(CharFromUnicodeScalarValue, utf32); Some(asChars)
  }

  import Base

  import Utf8EncodingForm

  import Utf16EncodingForm
}

module DafnyStdLibs.Unicode.Utf16EncodingForm refines UnicodeEncodingForm {
  function IsMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq): (b: bool)
  {
    if |s| == 1 then
      IsWellFormedSingleCodeUnitSequence(s)
    else if |s| == 2 then
      var b := IsWellFormedDoubleCodeUnitSequence(s);
      assert b ==> forall i | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i]);
      b
    else
      false
  }

  function IsWellFormedSingleCodeUnitSequence(s: CodeUnitSeq): (b: bool)
    requires |s| == 1
  {
    var firstWord := s[0];
    0 <= firstWord <= 55295 || 57344 <= firstWord <= 65535
  }

  function IsWellFormedDoubleCodeUnitSequence(s: CodeUnitSeq): (b: bool)
    requires |s| == 2
    ensures b ==> !IsWellFormedSingleCodeUnitSequence(s[..1])
  {
    var firstWord := s[0];
    var secondWord := s[1];
    55296 <= firstWord <= 56319 &&
    56320 <= secondWord <= 57343
  }

  function SplitPrefixMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq): (maybePrefix: Option<MinimalWellFormedCodeUnitSeq>)
    ensures |s| == 0 ==> maybePrefix.None?
    ensures (exists i | 0 < i <= |s| :: IsMinimalWellFormedCodeUnitSubsequence(s[..i])) <==> true && maybePrefix.Some?
    ensures maybePrefix.Some? ==> true && var prefix := maybePrefix.Extract(); 0 < |prefix| <= |s| && prefix == s[..|prefix|] && IsMinimalWellFormedCodeUnitSubsequence(prefix)
  {
    if |s| >= 1 && IsWellFormedSingleCodeUnitSequence(s[..1]) then
      Some(s[..1])
    else if |s| >= 2 && IsWellFormedDoubleCodeUnitSequence(s[..2]) then
      Some(s[..2])
    else
      None
  }

  function EncodeScalarValue(v: ScalarValue): (m: MinimalWellFormedCodeUnitSeq)
  {
    if 0 <= v <= 55295 || 57344 <= v <= 65535 then
      EncodeScalarValueSingleWord(v)
    else
      EncodeScalarValueDoubleWord(v)
  }

  function EncodeScalarValueSingleWord(v: ScalarValue): (m: MinimalWellFormedCodeUnitSeq)
    requires 0 <= v <= 55295 || 57344 <= v <= 65535
    ensures |m| == 1
    ensures IsWellFormedSingleCodeUnitSequence(m)
  {
    var firstWord := v as CodeUnit;
    [firstWord]
  }

  function EncodeScalarValueDoubleWord(v: ScalarValue): (m: MinimalWellFormedCodeUnitSeq)
    requires 65536 <= v <= 1114111
    ensures |m| == 2
    ensures IsWellFormedDoubleCodeUnitSequence(m)
  {
    var x2 := (v & 1023) as bv10;
    var x1 := (v & 64512 >> 10) as bv6;
    var u := (v & 2031616 >> 16) as bv5;
    var w := (u - 1) as bv4;
    var firstWord := 55296 | (w as CodeUnit << 6) | x1 as CodeUnit;
    var secondWord := 56320 | x2 as CodeUnit;
    [firstWord, secondWord]
  }

  function DecodeMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq): (v: ScalarValue)
  {
    if |m| == 1 then
      DecodeMinimalWellFormedCodeUnitSubsequenceSingleWord(m)
    else
      assert |m| == 2; DecodeMinimalWellFormedCodeUnitSubsequenceDoubleWord(m)
  }

  function DecodeMinimalWellFormedCodeUnitSubsequenceSingleWord(m: MinimalWellFormedCodeUnitSeq): (v: ScalarValue)
    requires |m| == 1
    ensures 0 <= v <= 55295 || 57344 <= v <= 65535
    ensures EncodeScalarValueSingleWord(v) == m
  {
    var firstWord := m[0];
    var x := firstWord as bv16;
    assert EncodeScalarValueSingleWord(x as ScalarValue) == m;
    x as ScalarValue
  }

  function {:rlimit 1200} DecodeMinimalWellFormedCodeUnitSubsequenceDoubleWord(m: MinimalWellFormedCodeUnitSeq): (v: ScalarValue)
    requires |m| == 2
    ensures 65536 <= v <= 1114111
    ensures EncodeScalarValueDoubleWord(v) == m
  {
    var firstWord := m[0];
    var secondWord := m[1];
    var x2 := (secondWord & 1023) as bv24;
    var x1 := (firstWord & 63) as bv24;
    var w := (firstWord & 960 >> 6) as bv24;
    var u := (w + 1) as bv24;
    var v := (u << 16) | (x1 << 10) | x2 as ScalarValue;
    assert {:split_here} true;
    assert EncodeScalarValueDoubleWord(v) == m;
    v
  }

  type CodeUnit = bv16
}

module DafnyStdLibs.Unicode.Utf8EncodingForm refines UnicodeEncodingForm {
  function IsMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq): (b: bool)
  {
    if |s| == 1 then
      var b := IsWellFormedSingleCodeUnitSequence(s);
      assert b ==> forall i | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i]);
      b
    else if |s| == 2 then
      var b := IsWellFormedDoubleCodeUnitSequence(s);
      assert b ==> forall i | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i]);
      b
    else if |s| == 3 then
      var b := IsWellFormedTripleCodeUnitSequence(s);
      assert b ==> forall i | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i]);
      b
    else if |s| == 4 then
      var b := IsWellFormedQuadrupleCodeUnitSequence(s);
      assert b ==> forall i | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i]);
      b
    else
      false
  }

  function IsWellFormedSingleCodeUnitSequence(s: CodeUnitSeq): (b: bool)
    requires |s| == 1
  {
    var firstByte := s[0];
    true &&
    0 <= firstByte <= 127
  }

  function IsWellFormedDoubleCodeUnitSequence(s: CodeUnitSeq): (b: bool)
    requires |s| == 2
    ensures b ==> true && !IsWellFormedSingleCodeUnitSequence(s[..1])
  {
    var firstByte := s[0];
    var secondByte := s[1];
    194 <= firstByte <= 223 &&
    128 <= secondByte <= 191
  }

  function IsWellFormedTripleCodeUnitSequence(s: CodeUnitSeq): (b: bool)
    requires |s| == 3
    ensures b ==> !IsWellFormedSingleCodeUnitSequence(s[..1]) && !IsWellFormedDoubleCodeUnitSequence(s[..2])
  {
    var firstByte := s[0];
    var secondByte := s[1];
    var thirdByte := s[2];
    ((firstByte == 224 && 160 <= secondByte <= 191) || (225 <= firstByte <= 236 && 128 <= secondByte <= 191) || (firstByte == 237 && 128 <= secondByte <= 159) || (238 <= firstByte <= 239 && 128 <= secondByte <= 191)) &&
    128 <= thirdByte <= 191
  }

  function IsWellFormedQuadrupleCodeUnitSequence(s: CodeUnitSeq): (b: bool)
    requires |s| == 4
    ensures b ==> !IsWellFormedSingleCodeUnitSequence(s[..1]) && !IsWellFormedDoubleCodeUnitSequence(s[..2]) && !IsWellFormedTripleCodeUnitSequence(s[..3])
  {
    var firstByte := s[0];
    var secondByte := s[1];
    var thirdByte := s[2];
    var fourthByte := s[3];
    ((firstByte == 240 && 144 <= secondByte <= 191) || (241 <= firstByte <= 243 && 128 <= secondByte <= 191) || (firstByte == 244 && 128 <= secondByte <= 143)) &&
    128 <= thirdByte <= 191 &&
    128 <= fourthByte <= 191
  }

  function SplitPrefixMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq): (maybePrefix: Option<MinimalWellFormedCodeUnitSeq>)
  {
    if |s| >= 1 && IsWellFormedSingleCodeUnitSequence(s[..1]) then
      Some(s[..1])
    else if |s| >= 2 && IsWellFormedDoubleCodeUnitSequence(s[..2]) then
      Some(s[..2])
    else if |s| >= 3 && IsWellFormedTripleCodeUnitSequence(s[..3]) then
      Some(s[..3])
    else if |s| >= 4 && IsWellFormedQuadrupleCodeUnitSequence(s[..4]) then
      Some(s[..4])
    else
      None
  }

  function EncodeScalarValue(v: ScalarValue): (m: MinimalWellFormedCodeUnitSeq)
  {
    if v <= 127 then
      EncodeScalarValueSingleByte(v)
    else if v <= 2047 then
      EncodeScalarValueDoubleByte(v)
    else if v <= 65535 then
      EncodeScalarValueTripleByte(v)
    else
      EncodeScalarValueQuadrupleByte(v)
  }

  function EncodeScalarValueSingleByte(v: ScalarValue): (m: MinimalWellFormedCodeUnitSeq)
    requires 0 <= v <= 127
    ensures |m| == 1
    ensures IsWellFormedSingleCodeUnitSequence(m)
  {
    var x := (v & 127) as bv7;
    var firstByte := x as CodeUnit;
    [firstByte]
  }

  function EncodeScalarValueDoubleByte(v: ScalarValue): (s: CodeUnitSeq)
    requires 128 <= v <= 2047
    ensures |s| == 2
    ensures IsWellFormedDoubleCodeUnitSequence(s)
  {
    var x := (v & 63) as bv6;
    var y := (v & 1984 >> 6) as bv5;
    var firstByte := 192 | y as CodeUnit;
    var secondByte := 128 | x as CodeUnit;
    [firstByte, secondByte]
  }

  function EncodeScalarValueTripleByte(v: ScalarValue): (s: CodeUnitSeq)
    requires 2048 <= v <= 65535
    ensures |s| == 3
    ensures IsWellFormedTripleCodeUnitSequence(s)
  {
    var x := (v & 63) as bv6;
    var y := (v & 4032 >> 6) as bv6;
    var z := (v & 61440 >> 12) as bv4;
    var firstByte := 224 | z as CodeUnit;
    var secondByte := 128 | y as CodeUnit;
    var thirdByte := 128 | x as CodeUnit;
    [firstByte, secondByte, thirdByte]
  }

  function EncodeScalarValueQuadrupleByte(v: ScalarValue): (s: CodeUnitSeq)
    requires 65536 <= v <= 1114111
    ensures |s| == 4
    ensures IsWellFormedQuadrupleCodeUnitSequence(s)
  {
    assert v <= 2097151;
    var x := (v & 63) as bv6;
    var y := (v & 4032 >> 6) as bv6;
    var z := (v & 61440 >> 12) as bv4;
    var u2 := (v & 196608 >> 16) as bv2;
    var u1 := (v & 1835008 >> 18) as bv3;
    var firstByte := 240 | u1 as CodeUnit;
    var secondByte := 128 | (u2 as CodeUnit << 4) | z as CodeUnit;
    var thirdByte := 128 | y as CodeUnit;
    var fourthByte := 128 | x as CodeUnit;
    [firstByte, secondByte, thirdByte, fourthByte]
  }

  function DecodeMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq): (v: ScalarValue)
  {
    if |m| == 1 then
      DecodeMinimalWellFormedCodeUnitSubsequenceSingleByte(m)
    else if |m| == 2 then
      DecodeMinimalWellFormedCodeUnitSubsequenceDoubleByte(m)
    else if |m| == 3 then
      DecodeMinimalWellFormedCodeUnitSubsequenceTripleByte(m)
    else
      assert |m| == 4; DecodeMinimalWellFormedCodeUnitSubsequenceQuadrupleByte(m)
  }

  function DecodeMinimalWellFormedCodeUnitSubsequenceSingleByte(m: MinimalWellFormedCodeUnitSeq): (v: ScalarValue)
    requires |m| == 1
    ensures 0 <= v <= 127
    ensures EncodeScalarValueSingleByte(v) == m
  {
    var firstByte := m[0];
    var x := firstByte as bv7;
    x as ScalarValue
  }

  function DecodeMinimalWellFormedCodeUnitSubsequenceDoubleByte(m: MinimalWellFormedCodeUnitSeq): (v: ScalarValue)
    requires |m| == 2
    ensures 128 <= v <= 2047
    ensures EncodeScalarValueDoubleByte(v) == m
  {
    var firstByte := m[0];
    var secondByte := m[1];
    var y := (firstByte & 31) as bv24;
    var x := (secondByte & 63) as bv24;
    (y << 6) | x as ScalarValue
  }

  function {:rlimit 115000} DecodeMinimalWellFormedCodeUnitSubsequenceTripleByte(m: MinimalWellFormedCodeUnitSeq): (v: ScalarValue)
    requires |m| == 3
    ensures 2048 <= v <= 65535
    ensures EncodeScalarValueTripleByte(v) == m
  {
    var firstByte := m[0];
    var secondByte := m[1];
    var thirdByte := m[2];
    var z := (firstByte & 15) as bv24;
    var y := (secondByte & 63) as bv24;
    var x := (thirdByte & 63) as bv24;
    assert {:split_here} true;
    (z << 12) | (y << 6) | x as ScalarValue
  }

  function {:rlimit 4000} DecodeMinimalWellFormedCodeUnitSubsequenceQuadrupleByte(m: MinimalWellFormedCodeUnitSeq): (v: ScalarValue)
    requires |m| == 4
    ensures 65536 <= v <= 1114111
    ensures EncodeScalarValueQuadrupleByte(v) == m
  {
    var firstByte := m[0];
    var secondByte := m[1];
    var thirdByte := m[2];
    var fourthByte := m[3];
    var u1 := (firstByte & 7) as bv24;
    var u2 := (secondByte & 48 >> 4) as bv24;
    var z := (secondByte & 15) as bv24;
    var y := (thirdByte & 63) as bv24;
    var x := (fourthByte & 63) as bv24;
    assert {:split_here} true;
    (u1 << 18) | (u2 << 16) | (z << 12) | (y << 6) | x as ScalarValue
  }

  type CodeUnit = bv8
}

module DafnyStdLibs.Unicode.Utf8EncodingScheme {
  function Serialize(s: Utf8EncodingForm.CodeUnitSeq): (b: seq<byte>)
  {
    Seqs.Map(c => c as byte, s)
  }

  function Deserialize(b: seq<byte>): (s: Utf8EncodingForm.CodeUnitSeq)
  {
    Seqs.Map(b => b as Utf8EncodingForm.CodeUnit, b)
  }

  lemma LemmaSerializeDeserialize(s: Utf8EncodingForm.CodeUnitSeq)
    ensures Deserialize(Serialize(s)) == s
  {
  }

  lemma {:rlimit 3000} LemmaDeserializeSerialize(b: seq<byte>)
    ensures Serialize(Deserialize(b)) == b
  {
    calc {
      Serialize(Deserialize(b));
    ==
      Seqs.Map(c => c as byte, Seqs.Map(b => b as Utf8EncodingForm.CodeUnit, b));
    ==
      Seqs.Map(b => b as Utf8EncodingForm.CodeUnit as byte, b);
    ==
      Seqs.Map(b => b, b);
    ==
      b;
    }
  }

  import opened Wrappers

  import BoundedInts

  import Seqs = Collections.Seqs

  import Utf8EncodingForm

  type byte = BoundedInts.uint8
}

module DafnyStdLibs.Wrappers {
  function Need<E>(condition: bool, error: E): (result: OutcomeResult<E>)
  {
    if condition then
      Pass'
    else
      Fail'(error)
  }

  datatype Option<+T> = None | Some(value: T) {
    predicate IsFailure()
    {
      None?
    }

    function PropagateFailure<U>(): Option<U>
      requires None?
    {
      None
    }

    function Extract(): T
      requires Some?
    {
      value
    }

    function GetOr(default: T): T
    {
      match this
      case Some(v) =>
        v
      case None() =>
        default
    }

    function ToResult<E>(error: E): Result<T, E>
    {
      match this
      case Some(v) =>
        Success(v)
      case None() =>
        Failure(error)
    }

    function ToOutcome<E>(error: E): Outcome<E>
    {
      match this
      case Some(v) =>
        Pass
      case None() =>
        Fail(error)
    }

    function Map<FC>(rewrap: Option<T> -> FC): FC
    {
      rewrap(this)
    }
  }

  datatype Result<+R, +E> = Success(value: R) | Failure(error: E) {
    predicate IsFailure()
    {
      Failure?
    }

    function PropagateFailure<U>(): (r: Result<U, E>)
      requires Failure?
    {
      Failure(this.error)
    }

    function Extract(): R
      requires Success?
    {
      value
    }

    function GetOr(default: R): R
    {
      match this
      case Success(s) =>
        s
      case Failure(e) =>
        default
    }

    function ToOption(): Option<R>
    {
      match this
      case Success(s) =>
        Some(s)
      case Failure(e) =>
        None()
    }

    function ToOutcome(): Outcome<E>
    {
      match this
      case Success(s) =>
        Pass
      case Failure(e) =>
        Fail(e)
    }

    function Map<FC>(rewrap: Result<R, E> -> FC): FC
    {
      rewrap(this)
    }

    function MapFailure<NewE>(reWrap: E -> NewE): Result<R, NewE>
    {
      match this
      case Success(s) =>
        Success(s)
      case Failure(e) =>
        Failure(reWrap(e))
    }
  }

  datatype Outcome<+E> = Pass | Fail(error: E) {
    predicate IsFailure()
    {
      Fail?
    }

    function PropagateFailure(): Outcome<E>
      requires Fail?
    {
      this
    }

    function ToOption<R>(r: R): Option<R>
    {
      match this
      case Pass =>
        Some(r)
      case Fail(e) =>
        None()
    }

    function ToResult<R>(r: R): Result<R, E>
    {
      match this
      case Pass =>
        Success(r)
      case Fail(e) =>
        Failure(e)
    }

    function Map<FC>(rewrap: Outcome<E> -> FC): FC
    {
      rewrap(this)
    }

    function MapFailure<T, NewE>(rewrap: E -> NewE, default: T): Result<T, NewE>
    {
      match this
      case Pass =>
        Success(default)
      case Fail(e) =>
        Failure(rewrap(e))
    }

    static function Need(condition: bool, error: E): (result: Outcome<E>)
    {
      if condition then
        Pass
      else
        Fail(error)
    }
  }

  datatype OutcomeResult<+E> = Pass' | Fail'(error: E) {
    predicate IsFailure()
    {
      Fail'?
    }

    function PropagateFailure<U>(): Result<U, E>
      requires IsFailure()
    {
      Failure(this.error)
    }
  }
}
