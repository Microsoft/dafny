using System.Collections.Generic;
using System.Linq;
using OmniSharp.Extensions.LanguageServer.Protocol.Models;

namespace Microsoft.Dafny;

public abstract class MethodOrFunction : MemberDecl, ICallable {
  public readonly List<AttributedExpression> Req;
  public readonly List<AttributedExpression> Ens;
  public readonly List<Call> Calls;

  protected MethodOrFunction(RangeToken rangeToken, Name name, bool hasStaticKeyword, bool isAlien, bool isGhost,
    Attributes attributes, bool isRefining, List<TypeParameter> typeArgs,
    List<AttributedExpression> req,
    List<AttributedExpression> ens,
    Specification<Expression> decreases,
    List<Call> calls)
    : base(rangeToken, name, hasStaticKeyword, isGhost, attributes, isRefining) {
    TypeArgs = typeArgs;
    Req = req;
    Ens = ens;
    Decreases = decreases;
    Calls = calls;
    IsAlien = isAlien;
  }

  protected MethodOrFunction(Cloner cloner, MethodOrFunction original) : base(cloner, original) {
    TypeArgs = cloner.CloneResolvedFields ? original.TypeArgs : original.TypeArgs.ConvertAll(cloner.CloneTypeParam);
    Req = original.Req.ConvertAll(cloner.CloneAttributedExpr);
    Ens = original.Ens.ConvertAll(cloner.CloneAttributedExpr);
    Decreases = cloner.CloneSpecExpr(original.Decreases);
    Calls = original.Calls.ConvertAll(call => new Call(cloner, call));
    IsAlien = original.IsAlien;
  }

  protected abstract bool Bodyless { get; }
  protected abstract string TypeName { get; }

  public bool IsVirtual => EnclosingClass is TraitDecl && !IsStatic;
  public bool IsAbstract => EnclosingClass.EnclosingModuleDefinition.ModuleKind != ModuleKindEnum.Concrete;
  public bool IsAlien { get; }

  public virtual void Resolve(ModuleResolver resolver) {
    ResolveMethodOrFunction(resolver);
  }

  public void ResolveMethodOrFunction(INewOrOldResolver resolver) {
    if (!AutoGeneratedToken.Is(RangeToken) && Bodyless && !IsVirtual && !IsAbstract && !this.IsExtern(resolver.Options) && !this.IsExplicitAxiom()) {
      foreach (var ensures in Ens) {
        if (!ensures.IsExplicitAxiom() && !resolver.Options.Get(CommonOptionBag.AllowAxioms)) {
          resolver.Reporter.Warning(MessageSource.Verifier, ResolutionErrors.ErrorId.none, ensures.Tok,
            $"This ensures clause is part of a bodyless {TypeName}. Add the {{:axiom}} attribute to it or the enclosing {TypeName} to suppress this warning");
        }
      }
    }
  }

  protected MethodOrFunction(RangeToken tok, Name name, bool hasStaticKeyword, bool isGhost, Attributes attributes, bool isRefining) : base(tok, name, hasStaticKeyword, isGhost, attributes, isRefining) {
  }

  public abstract ModuleDefinition EnclosingModule { get; }
  public List<TypeParameter> TypeArgs { set; get; }
  public abstract List<Formal> Ins { get; }
  public abstract bool MustReverify { get; }
  public abstract bool AllowsNontermination { get; }
  public abstract SymbolKind Kind { get; }
  public abstract string GetDescription(DafnyOptions options);
  public abstract string Designator { get; }
  public abstract string NameRelativeToModule { get; }
  public Specification<Expression> Decreases { get; }
  public abstract bool InferredDecreases { get; set; }
  public abstract bool AllowsAllocation { get; }
}

public class Call : TokenNode {
  public Expression QualifiedName;
  [FilledInDuringResolution] public MethodOrFunction Target;
  public bool Recursive;

  public Call(Expression name, bool recursive) {
    QualifiedName = name;
    Recursive = recursive;
  }

  public Call(Cloner cloner, Call original) {
    QualifiedName = cloner.CloneExpr(original.QualifiedName);
    Recursive = original.Recursive;
  }

  public override IEnumerable<INode> Children => Enumerable.Empty<Node>();
  public override IEnumerable<INode> PreResolveChildren => Enumerable.Empty<Node>();
}