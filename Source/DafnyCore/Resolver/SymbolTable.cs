using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using IntervalTree;
using Microsoft.Boogie;
using Microsoft.Dafny.LanguageServer.Language;
// using Microsoft.Dafny.LanguageServer.Language;
using OmniSharp.Extensions.LanguageServer.Protocol;
using OmniSharp.Extensions.LanguageServer.Protocol.Models;
using Range = OmniSharp.Extensions.LanguageServer.Protocol.Models.Range;

namespace Microsoft.Dafny;

public class SymbolTable {

  public static SymbolTable CreateFrom(Program program) {
    var visited = program.Visit(a => true, b => { });

    var usages = visited.OfType<IHasUsages>().Where(v => !AutoGeneratedToken.Is(v.NameToken))
      .SelectMany(r => r.GetResolvedDeclarations().Select(declaration =>
        ((IDeclarationOrUsage)r, declaration))).ToList();

    return new SymbolTable(usages);
  }
  
  public static SymbolTable Empty() {
    return new SymbolTable();
  }

  private SymbolTable() {
    Usages = ImmutableDictionary<IDeclarationOrUsage, ISet<IDeclarationOrUsage>>.Empty;
    Declarations = ImmutableDictionary<IDeclarationOrUsage, IDeclarationOrUsage>.Empty;
  }

  public SymbolTable(IReadOnlyList<(IDeclarationOrUsage usage, IDeclarationOrUsage declaration)> usages) {
    var safeUsages = usages.Where(k => k.usage.NameToken.Uri != null && k.declaration.NameToken.Uri != null).ToList();
    Declarations = safeUsages.DistinctBy(k => k.usage).
      ToImmutableDictionary(k => k.usage, k => k.declaration);
    Usages = safeUsages.GroupBy(u => u.declaration).ToImmutableDictionary(
      g => g.Key,
      g => (ISet<IDeclarationOrUsage>)g.Select(k => k.usage).ToHashSet());

    var symbols = safeUsages.Select(u => u.declaration).
      Concat(safeUsages.Select(u => u.usage)).
      Where(s => !AutoGeneratedToken.Is(s.NameToken));
    var symbolsByFile = symbols.GroupBy(s => s.NameToken.Uri);
    foreach (var symbolsForFile in symbolsByFile) {
      var nodePositions = new IntervalTree<Position, IDeclarationOrUsage>();
      this.nodePositions.Add(symbolsForFile.Key, nodePositions);
      foreach (var symbolForFile in symbolsForFile) {
        var range = symbolForFile.NameToken.GetLspRange();
        nodePositions.Add(range.Start, range.End, symbolForFile);
      }
    }
  }

  private readonly Dictionary<Uri, IIntervalTree<Position, IDeclarationOrUsage>> nodePositions = new();
  private ImmutableDictionary<IDeclarationOrUsage, IDeclarationOrUsage> Declarations { get; }
  private ImmutableDictionary<IDeclarationOrUsage, ISet<IDeclarationOrUsage>> Usages { get; }

  public ISet<Location> GetUsages(Uri uri, Position position) {
    if (nodePositions.TryGetValue(uri, out var forFile)) {
      return forFile.Query(position).
        SelectMany(node => Usages.GetOrDefault(node, () => (ISet<IDeclarationOrUsage>)new HashSet<IDeclarationOrUsage>())).
        Select(u => new Location { Uri = u.NameToken.Filepath, Range = u.NameToken.GetLspRange() }).ToHashSet();
    }
    return Sets.Empty<Location>();
  }

  public Location? GetDeclaration(Uri uri, Position position) {
    if (!nodePositions.TryGetValue(uri, out var forFile)) {
      return null;
    }

    var referenceNodes = forFile.Query(position);
    return referenceNodes.Select(node => Declarations.GetOrDefault(node, () => (IDeclarationOrUsage?)null))
      .Where(x => x != null).Select(
        n => new Location {
          Uri = DocumentUri.From(n!.NameToken.Uri),
          Range = n.NameToken.GetLspRange()
        }).FirstOrDefault();
  }

  public Graph<ISymbol> UsageGraph() {
    var todo = new Stack<ISymbol>(Usages.Keys.OfType<ISymbol>()); // TODO replace cast
    var visited = new HashSet<ISymbol>();
    var graph = new Graph<ISymbol>();
    while (todo.Any()) {
      var current = todo.Pop();
      if (!visited.Add(current)) {
        continue;
      }

      var children = (current as IHasSymbolChildren)?.ChildSymbols ?? Enumerable.Empty<ISymbol>();
      var rangePositions = new[] { current.RangeToken.StartToken.GetLspPosition() }
        .Concat(children.SelectMany(child => new [] {
          child.RangeToken.StartToken.GetLspPosition(), 
          child.RangeToken.EndToken.GetLspPosition(true)
        }))
        .Concat(new [] { current.RangeToken.EndToken.GetLspPosition(true) }).ToList();
      var ranges = Enumerable.Range(0, rangePositions.Count / 2)
        .Select(index => new Range(rangePositions[index * 2], rangePositions[index * 2 + 1]));
      var positions = nodePositions[current.RangeToken.Uri];
      foreach (var range in ranges) {
        var usages = positions.Query(range.Start, range.End);
        foreach (var usage in usages) {
          var declaration = Declarations.GetValueOrDefault(usage) as ISymbol; // TODO replace cast.
          if (declaration != null) {
            graph.AddEdge(current, declaration);
            todo.Push(declaration); 
          }
        }
      }
    }

    return graph;
  }
  
  public ISet<TopLevelDecl> ReachableFrom(ModuleDefinition module) {
    var todo = new Stack<IDeclarationOrUsage>(module.TopLevelDecls);
    var visited = new HashSet<IDeclarationOrUsage>();
    while (todo.Any()) {
      var current = todo.Pop();
      if (!visited.Add(current)) {
        continue;
      }

      var positions = nodePositions[current.RangeToken.Uri];
      var usages = positions.Query(current.RangeToken.StartToken.GetLspPosition(), current.RangeToken.EndToken.GetLspPosition());
      foreach (var usage in usages) {
        var declaration = Declarations.GetValueOrDefault(usage);
        if (declaration != null) {
          todo.Push(declaration);
        }
      }
    }

    return visited.OfType<TopLevelDecl>().ToHashSet();
  }
}