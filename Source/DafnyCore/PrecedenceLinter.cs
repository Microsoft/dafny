//-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
// Copyright by the contributors to the Dafny Project
// SPDX-License-Identifier: MIT
//
//-----------------------------------------------------------------------------
using System.Collections.Generic;
using System.Linq;
using System;
using System.Diagnostics.Contracts;
using JetBrains.Annotations;
using Microsoft.Boogie;

namespace Microsoft.Dafny {

  public class PrecedenceLinter : IRewriter {
    internal override void PostResolve(Program program) {
      base.PostResolve(program);
      foreach (var moduleDefinition in program.Modules()) {
        foreach (var topLevelDecl in moduleDefinition.TopLevelDecls.OfType<TopLevelDeclWithMembers>()) {
          foreach (var callable in topLevelDecl.Members.OfType<ICallable>()) {
            var visitor = new PrecedenceLinterVisitor(this.Reporter);
            visitor.Visit(callable, null);
          }
        }
      }
    }

    public PrecedenceLinter(ErrorReporter reporter) : base(reporter) {
    }
  }

  class LeftMargin {
    public int Column;

    public LeftMargin(int column) {
      Column = column;
    }
  }

  class PrecedenceLinterVisitor : TopDownVisitor<LeftMargin> {

    private readonly ErrorReporter reporter;

    public PrecedenceLinterVisitor(ErrorReporter reporter) {
      this.reporter = reporter;
    }

    protected override bool VisitOneExpr(Expression expr, ref LeftMargin st) {
      if (AutoGeneratedToken.Is(expr.tok) || expr is DefaultValueExpression) {
        return false; // don't traverse further
      }

      if (st != null) {
        int column;
        if (expr is DatatypeUpdateExpr or SeqSelectExpr or SeqUpdateExpr or MultiSelectExpr or TernaryExpr) {
          // These expressions are handled below as being all-independent components, which means the
          // formatting of their internal structure is not relevant to the enclosing context. Yet, the .tok of
          // these expressions sits someone inside that internal structure (for example, the .tok of
          // a SeqSelectExpr is the open-bracket). To avoid looking at that internal structure, we instead
          // use the .StartToken for these expressions.
          column = expr.StartToken.col;
        } else {
          column = expr.tok.col;
        }
        if (column < st.Column) {
          st.Column = column;
        }
      }

      // Our aim is to try to detect if some expressions are longer than the user intended.
      // This can happen if the user accidentally left off parentheses around a lower-precedence
      // operator (e.g., ==>). As a guide, we look at how the user formatted the code,
      // that is, we inspect line and column information.

      if (expr is BinaryExpr bin && (bin.Op == BinaryExpr.Opcode.Imp || bin.Op == BinaryExpr.Opcode.Exp || bin.Op == BinaryExpr.Opcode.Iff)) {
        VisitLhsComponent(expr.tok, bin.E0,
          // For
          //   a)  LHS ==> RHS
          //   b)  LHS ==>
          // use LHS.StartToken as the left margin.
          bin.E0.StartToken.line == expr.tok.line ? bin.E0.StartToken.col :
          // For
          //   c)  LHS0 &&
          //       LHS1 ==> RHS
          // use expr.tok (that is, the location of ==>) as the left margin. This is bound to generate a warning.
          bin.E1.StartToken.line == expr.tok.line ? expr.tok.col :
          // For
          //   d)  LHS0 &&
          //       LHS1 ==>
          //   e)  LHS0 &&
          //       LHS1
          //       ==>
          // use LHS.StartToken as the left margin.
          bin.E0.StartToken.col,
          "left-hand operand of " + BinaryExpr.OpcodeString(bin.Op));
        VisitRhsComponent(expr.tok, bin.E1, "right-hand operand of " + BinaryExpr.OpcodeString(bin.Op));
        return false; // indicate that we've already processed expr's subexpressions

      } else if (expr is ITEExpr ifThenElse) {
        VisitIndependentComponent(ifThenElse.Test);
        VisitIndependentComponent(ifThenElse.Thn);
        VisitRhsComponent(expr.tok, ifThenElse.Els, "else branch of if-then-else");
        return false; // indicate that we've already processed expr's subexpressions

      } else if (expr is QuantifierExpr quantifierExpr) {
        Attributes.SubExpressions(quantifierExpr.Attributes).Iter(VisitIndependentComponent);
        if (quantifierExpr.Range != null) {
          VisitIndependentComponent(quantifierExpr.Range);
        }
        VisitRhsComponent(expr.tok, quantifierExpr.Term,
          expr.tok.line == quantifierExpr.Term.StartToken.line ? expr.tok.col + 1 : quantifierExpr.Term.StartToken.col,
          "body of " + (expr is ForallExpr ? "forall" : "exists"));
        return false; // indicate that we've already processed expr's subexpressions

      } else if (expr is LetExpr letExpr) {
        Attributes.SubExpressions(letExpr.Attributes).Iter(VisitIndependentComponent);
        letExpr.RHSs.Iter(VisitIndependentComponent);
        VisitRhsComponent(expr.tok, letExpr.Body, "body of let-expression");
        return false; // indicate that we've already processed expr's subexpressions

      } else if (expr is OldExpr or FreshExpr or UnchangedExpr or DatatypeValue or DisplayExpression or MapDisplayExpr) {
        // In these expressions, all subexpressions are contained in parentheses, so there's no risk of precedence confusion
        expr.SubExpressions.Iter(VisitIndependentComponent);
        return false; // indicate that we've already processed expr's subexpressions

      } else if (expr is FunctionCallExpr or ApplyExpr or DatatypeUpdateExpr or SeqSelectExpr or SeqUpdateExpr or MultiSelectExpr or TernaryExpr) {
        // These expressions have the form
        //     rootExpr  OPEN-BRACKET   arguments   CLOSE-BRACKET
        // (Well, TernaryExpr isn't quite like that, but one can say something similar about it.)
        // Certainly, all subexpressions contained within the parentheses/brackets have no risk of precedence confusion.
        // Moreover, because the open parenthesis/bracket has such a high and well-known precedence, it doesn't
        // seem likely that there would be any confusion about its precedence, either. Therefore, we treat
        // all subexpressions of "expr" as independent components.
        expr.SubExpressions.Iter(VisitIndependentComponent);
        return false; // indicate that we've already processed expr's subexpressions

      } else if (expr is NestedMatchExpr nestedMatchExpr) {
        // Handle each case like the "else" of an if-then-else
        Attributes.SubExpressions(nestedMatchExpr.Attributes).Iter(VisitIndependentComponent);
        VisitIndependentComponent(nestedMatchExpr.Source);
        var n = nestedMatchExpr.Cases.Count;
        for (var i = 0; i < n; i++) {
          var body = nestedMatchExpr.Cases[i].Body;
#if REVISIT_AFTER_PR_2734
          if (i == n - 1 && !nestedMatchExpr.UsesOptionalBraces) {
            VisitRhsComponent(body.StartToken, body, "case expression");
          } else {
            VisitIndependentComponent(body);
          }
#else
          VisitIndependentComponent(body);
#endif
        }
        return false; // indicate that we've already processed expr's subexpressions
      }

      return base.VisitOneExpr(expr, ref st);
    }

    void VisitIndependentComponent(Expression expr) {
      Visit(expr, null);
    }

    void VisitLhsComponent(IToken errorToken, Expression expr, int leftMargin, string what) {
      if (expr is ParensExpression || expr.StartToken.line == errorToken.line) {
        VisitIndependentComponent(expr);
      } else {
        var st = new LeftMargin(leftMargin);
        Visit(expr, st);
        if (st.Column < leftMargin) {
          this.reporter.Warning(MessageSource.Rewriter, errorToken,
            $"unusual indentation in {what} (which starts at {LineCol(expr.StartToken)}); do you perhaps need parentheses?");
        }
      }
    }

    void VisitRhsComponent(IToken errorToken, Expression expr, string what) {
      VisitRhsComponent(errorToken, expr, expr.StartToken.col, what);
    }

    void VisitRhsComponent(IToken errorToken, Expression expr, int rightMargin, string what) {
      if (expr is ParensExpression) {
        VisitIndependentComponent(expr);
      } else {
        var st = new LeftMargin(rightMargin);
        Visit(expr, st);
        if (st.Column < rightMargin) {
          this.reporter.Warning(MessageSource.Rewriter, errorToken,
            $"unusual indentation in {what} (which ends at {LineCol(expr.EndToken)}); do you perhaps need parentheses?");
        }
      }
    }

    static string LineCol(IToken tok) {
      return $"line {tok.line}, column {tok.col}";
    }
  }
}
